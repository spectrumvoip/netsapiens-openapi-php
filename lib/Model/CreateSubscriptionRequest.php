<?php
/**
 * CreateSubscriptionRequest
 *
 * PHP version 7.4
 *
 * @category Class
 * @package  SpectrumVoip\\\\NetSapiens
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * NetSapiens API v2
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.10.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace SpectrumVoip\\\\NetSapiens\Model;

use \ArrayAccess;
use \SpectrumVoip\\\\NetSapiens\ObjectSerializer;

/**
 * CreateSubscriptionRequest Class Doc Comment
 *
 * @category Class
 * @package  SpectrumVoip\\\\NetSapiens
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 * @implements \ArrayAccess<string, mixed>
 */
class CreateSubscriptionRequest implements ModelInterface, ArrayAccess, \JsonSerializable
{
    public const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static $openAPIModelName = 'CreateSubscription_request';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $openAPITypes = [
        'model' => 'string',
        'post_url' => 'string',
        'subscription_geo_support' => '\SpectrumVoip\\\\NetSapiens\Model\YesNoStringYesDefault',
        'reseller' => 'string',
        'domain' => 'string',
        'user' => 'string',
        'preferred_server' => 'string'
    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var string[]
      * @phpstan-var array<string, string|null>
      * @psalm-var array<string, string|null>
      */
    protected static $openAPIFormats = [
        'model' => null,
        'post_url' => 'url',
        'subscription_geo_support' => null,
        'reseller' => null,
        'domain' => null,
        'user' => null,
        'preferred_server' => 'hostname'
    ];

    /**
      * Array of nullable properties. Used for (de)serialization
      *
      * @var boolean[]
      */
    protected static array $openAPINullables = [
        'model' => false,
        'post_url' => false,
        'subscription_geo_support' => false,
        'reseller' => false,
        'domain' => false,
        'user' => false,
        'preferred_server' => false
    ];

    /**
      * If a nullable field gets set to null, insert it here
      *
      * @var boolean[]
      */
    protected array $openAPINullablesSetToNull = [];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPITypes()
    {
        return self::$openAPITypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPIFormats()
    {
        return self::$openAPIFormats;
    }

    /**
     * Array of nullable properties
     *
     * @return array
     */
    protected static function openAPINullables(): array
    {
        return self::$openAPINullables;
    }

    /**
     * Array of nullable field names deliberately set to null
     *
     * @return boolean[]
     */
    private function getOpenAPINullablesSetToNull(): array
    {
        return $this->openAPINullablesSetToNull;
    }

    /**
     * Setter - Array of nullable field names deliberately set to null
     *
     * @param boolean[] $openAPINullablesSetToNull
     */
    private function setOpenAPINullablesSetToNull(array $openAPINullablesSetToNull): void
    {
        $this->openAPINullablesSetToNull = $openAPINullablesSetToNull;
    }

    /**
     * Checks if a property is nullable
     *
     * @param string $property
     * @return bool
     */
    public static function isNullable(string $property): bool
    {
        return self::openAPINullables()[$property] ?? false;
    }

    /**
     * Checks if a nullable property is set to null.
     *
     * @param string $property
     * @return bool
     */
    public function isNullableSetToNull(string $property): bool
    {
        return in_array($property, $this->getOpenAPINullablesSetToNull(), true);
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'model' => 'model',
        'post_url' => 'post-url',
        'subscription_geo_support' => 'subscription-geo-support',
        'reseller' => 'reseller',
        'domain' => 'domain',
        'user' => 'user',
        'preferred_server' => 'preferred-server'
    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var string[]
     */
    protected static $setters = [
        'model' => 'setModel',
        'post_url' => 'setPostUrl',
        'subscription_geo_support' => 'setSubscriptionGeoSupport',
        'reseller' => 'setReseller',
        'domain' => 'setDomain',
        'user' => 'setUser',
        'preferred_server' => 'setPreferredServer'
    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var string[]
     */
    protected static $getters = [
        'model' => 'getModel',
        'post_url' => 'getPostUrl',
        'subscription_geo_support' => 'getSubscriptionGeoSupport',
        'reseller' => 'getReseller',
        'domain' => 'getDomain',
        'user' => 'getUser',
        'preferred_server' => 'getPreferredServer'
    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array
     */
    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array
     */
    public static function setters()
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array
     */
    public static function getters()
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName()
    {
        return self::$openAPIModelName;
    }

    public const MODEL_AGENT = 'agent';
    public const MODEL_AUDITLOG = 'auditlog';
    public const MODEL_AUDITLOG_LITE = 'auditlog_lite';
    public const MODEL_CALL = 'call';
    public const MODEL_CALL_ORIGID = 'call_origid';
    public const MODEL_CDR = 'cdr';
    public const MODEL_MESSAGE = 'message';
    public const MODEL_MESSAGESESSION = 'messagesession';
    public const MODEL_SUBSCRIBER = 'subscriber';
    public const MODEL_PRESENCE = 'presence';
    public const MODEL_VOICEMAIL = 'voicemail';

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getModelAllowableValues()
    {
        return [
            self::MODEL_AGENT,
            self::MODEL_AUDITLOG,
            self::MODEL_AUDITLOG_LITE,
            self::MODEL_CALL,
            self::MODEL_CALL_ORIGID,
            self::MODEL_CDR,
            self::MODEL_MESSAGE,
            self::MODEL_MESSAGESESSION,
            self::MODEL_SUBSCRIBER,
            self::MODEL_PRESENCE,
            self::MODEL_VOICEMAIL,
        ];
    }

    /**
     * Associative array for storing property values
     *
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     *
     * @param mixed[] $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(array $data = null)
    {
        $this->setIfExists('model', $data ?? [], null);
        $this->setIfExists('post_url', $data ?? [], null);
        $this->setIfExists('subscription_geo_support', $data ?? [], null);
        $this->setIfExists('reseller', $data ?? [], null);
        $this->setIfExists('domain', $data ?? [], '*');
        $this->setIfExists('user', $data ?? [], '*');
        $this->setIfExists('preferred_server', $data ?? [], null);
    }

    /**
    * Sets $this->container[$variableName] to the given data or to the given default Value; if $variableName
    * is nullable and its value is set to null in the $fields array, then mark it as "set to null" in the
    * $this->openAPINullablesSetToNull array
    *
    * @param string $variableName
    * @param array  $fields
    * @param mixed  $defaultValue
    */
    private function setIfExists(string $variableName, array $fields, $defaultValue): void
    {
        if (self::isNullable($variableName) && array_key_exists($variableName, $fields) && is_null($fields[$variableName])) {
            $this->openAPINullablesSetToNull[] = $variableName;
        }

        $this->container[$variableName] = $fields[$variableName] ?? $defaultValue;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalidProperties = [];

        $allowedValues = $this->getModelAllowableValues();
        if (!is_null($this->container['model']) && !in_array($this->container['model'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'model', must be one of '%s'",
                $this->container['model'],
                implode("', '", $allowedValues)
            );
        }

        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {
        return count($this->listInvalidProperties()) === 0;
    }


    /**
     * Gets model
     *
     * @return string|null
     */
    public function getModel()
    {
        return $this->container['model'];
    }

    /**
     * Sets model
     *
     * @param string|null $model This is the type of data that will be sent. you will need to reqest multiple subscriptions if you want more than one model. Addtional details available in guide at https://docs.ns-api.com/docs/event-subscriptions-1
     *
     * @return self
     */
    public function setModel($model)
    {
        if (is_null($model)) {
            throw new \InvalidArgumentException('non-nullable model cannot be null');
        }
        $allowedValues = $this->getModelAllowableValues();
        if (!in_array($model, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'model', must be one of '%s'",
                    $model,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['model'] = $model;

        return $this;
    }

    /**
     * Gets post_url
     *
     * @return string|null
     */
    public function getPostUrl()
    {
        return $this->container['post_url'];
    }

    /**
     * Sets post_url
     *
     * @param string|null $post_url This is the url the API will be posting data to. Should be in the format including https://. Can make a custom port if needed and the URL should have a valid SSL certificate as well. Http:// is supproted but not ideal for production.
     *
     * @return self
     */
    public function setPostUrl($post_url)
    {
        if (is_null($post_url)) {
            throw new \InvalidArgumentException('non-nullable post_url cannot be null');
        }
        $this->container['post_url'] = $post_url;

        return $this;
    }

    /**
     * Gets subscription_geo_support
     *
     * @return \SpectrumVoip\\\\NetSapiens\Model\YesNoStringYesDefault|null
     */
    public function getSubscriptionGeoSupport()
    {
        return $this->container['subscription_geo_support'];
    }

    /**
     * Sets subscription_geo_support
     *
     * @param \SpectrumVoip\\\\NetSapiens\Model\YesNoStringYesDefault|null $subscription_geo_support When enabled this rule is available to be user though it may not be active as the timeframe might not match the current time or there could be other hihger priority timeframes.
     *
     * @return self
     */
    public function setSubscriptionGeoSupport($subscription_geo_support)
    {
        if (is_null($subscription_geo_support)) {
            throw new \InvalidArgumentException('non-nullable subscription_geo_support cannot be null');
        }
        $this->container['subscription_geo_support'] = $subscription_geo_support;

        return $this;
    }

    /**
     * Gets reseller
     *
     * @return string|null
     */
    public function getReseller()
    {
        return $this->container['reseller'];
    }

    /**
     * Sets reseller
     *
     * @param string|null $reseller This is the reseller that the subscription will filter data for. * will be used for all resellers, but only valid with Super User scope on the request.
     *
     * @return self
     */
    public function setReseller($reseller)
    {
        if (is_null($reseller)) {
            throw new \InvalidArgumentException('non-nullable reseller cannot be null');
        }
        $this->container['reseller'] = $reseller;

        return $this;
    }

    /**
     * Gets domain
     *
     * @return string|null
     */
    public function getDomain()
    {
        return $this->container['domain'];
    }

    /**
     * Sets domain
     *
     * @param string|null $domain This is the domain that the subscription will filter data for. \"*\" will be used for all domains, but only valid with Super User scope
     *
     * @return self
     */
    public function setDomain($domain)
    {
        if (is_null($domain)) {
            throw new \InvalidArgumentException('non-nullable domain cannot be null');
        }
        $this->container['domain'] = $domain;

        return $this;
    }

    /**
     * Gets user
     *
     * @return string|null
     */
    public function getUser()
    {
        return $this->container['user'];
    }

    /**
     * Sets user
     *
     * @param string|null $user This is the user that the subscription will filter data for. * will be used for all users.
     *
     * @return self
     */
    public function setUser($user)
    {
        if (is_null($user)) {
            throw new \InvalidArgumentException('non-nullable user cannot be null');
        }
        $this->container['user'] = $user;

        return $this;
    }

    /**
     * Gets preferred_server
     *
     * @return string|null
     */
    public function getPreferredServer()
    {
        return $this->container['preferred_server'];
    }

    /**
     * Sets preferred_server
     *
     * @param string|null $preferred_server This is the server hostname for the prefered server for this subscription, meaning if this server is up and online it will be the one sending the events. It wil fail back to this servre after 60s of stability.
     *
     * @return self
     */
    public function setPreferredServer($preferred_server)
    {
        if (is_null($preferred_server)) {
            throw new \InvalidArgumentException('non-nullable preferred_server cannot be null');
        }
        $this->container['preferred_server'] = $preferred_server;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer $offset Offset
     *
     * @return boolean
     */
    public function offsetExists($offset): bool
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer $offset Offset
     *
     * @return mixed|null
     */
    #[\ReturnTypeWillChange]
    public function offsetGet($offset)
    {
        return $this->container[$offset] ?? null;
    }

    /**
     * Sets value based on offset.
     *
     * @param int|null $offset Offset
     * @param mixed    $value  Value to be set
     *
     * @return void
     */
    public function offsetSet($offset, $value): void
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer $offset Offset
     *
     * @return void
     */
    public function offsetUnset($offset): void
    {
        unset($this->container[$offset]);
    }

    /**
     * Serializes the object to a value that can be serialized natively by json_encode().
     * @link https://www.php.net/manual/en/jsonserializable.jsonserialize.php
     *
     * @return mixed Returns data which can be serialized by json_encode(), which is a value
     * of any type other than a resource.
     */
    #[\ReturnTypeWillChange]
    public function jsonSerialize()
    {
       return ObjectSerializer::sanitizeForSerialization($this);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString()
    {
        return json_encode(
            ObjectSerializer::sanitizeForSerialization($this),
            JSON_PRETTY_PRINT
        );
    }

    /**
     * Gets a header-safe presentation of the object
     *
     * @return string
     */
    public function toHeaderValue()
    {
        return json_encode(ObjectSerializer::sanitizeForSerialization($this));
    }
}


