<?php
/**
 * Subscription
 *
 * PHP version 7.4
 *
 * @category Class
 * @package  SpectrumVoip\\\\NetSapiens
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * NetSapiens API v2
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.10.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace SpectrumVoip\\\\NetSapiens\Model;

use \ArrayAccess;
use \SpectrumVoip\\\\NetSapiens\ObjectSerializer;

/**
 * Subscription Class Doc Comment
 *
 * @category Class
 * @package  SpectrumVoip\\\\NetSapiens
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 * @implements \ArrayAccess<string, mixed>
 */
class Subscription implements ModelInterface, ArrayAccess, \JsonSerializable
{
    public const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static $openAPIModelName = 'Subscription';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $openAPITypes = [
        'id' => 'string',
        'model' => 'string',
        'post_url' => 'string',
        'subscription_geo_support' => '\SpectrumVoip\\\\NetSapiens\Model\YesNoStringYesDefault',
        'user_scope' => '\SpectrumVoip\\\\NetSapiens\Model\Scopes',
        'reseller' => 'string',
        'domain' => 'string',
        'user' => 'string',
        'subscription_creation_datetime' => '\DateTime',
        'subscription_expires_datetime' => '\DateTime',
        'preferred_server' => 'string',
        'current_active_server' => 'string',
        'status' => 'string',
        'error_count' => 'int',
        'posts_count' => 'int'
    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var string[]
      * @phpstan-var array<string, string|null>
      * @psalm-var array<string, string|null>
      */
    protected static $openAPIFormats = [
        'id' => null,
        'model' => null,
        'post_url' => 'url',
        'subscription_geo_support' => null,
        'user_scope' => null,
        'reseller' => null,
        'domain' => null,
        'user' => null,
        'subscription_creation_datetime' => 'date-time',
        'subscription_expires_datetime' => 'date-time',
        'preferred_server' => 'hostname',
        'current_active_server' => 'hostname',
        'status' => null,
        'error_count' => null,
        'posts_count' => null
    ];

    /**
      * Array of nullable properties. Used for (de)serialization
      *
      * @var boolean[]
      */
    protected static array $openAPINullables = [
        'id' => false,
        'model' => false,
        'post_url' => false,
        'subscription_geo_support' => false,
        'user_scope' => false,
        'reseller' => false,
        'domain' => false,
        'user' => false,
        'subscription_creation_datetime' => false,
        'subscription_expires_datetime' => false,
        'preferred_server' => false,
        'current_active_server' => false,
        'status' => false,
        'error_count' => false,
        'posts_count' => false
    ];

    /**
      * If a nullable field gets set to null, insert it here
      *
      * @var boolean[]
      */
    protected array $openAPINullablesSetToNull = [];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPITypes()
    {
        return self::$openAPITypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPIFormats()
    {
        return self::$openAPIFormats;
    }

    /**
     * Array of nullable properties
     *
     * @return array
     */
    protected static function openAPINullables(): array
    {
        return self::$openAPINullables;
    }

    /**
     * Array of nullable field names deliberately set to null
     *
     * @return boolean[]
     */
    private function getOpenAPINullablesSetToNull(): array
    {
        return $this->openAPINullablesSetToNull;
    }

    /**
     * Setter - Array of nullable field names deliberately set to null
     *
     * @param boolean[] $openAPINullablesSetToNull
     */
    private function setOpenAPINullablesSetToNull(array $openAPINullablesSetToNull): void
    {
        $this->openAPINullablesSetToNull = $openAPINullablesSetToNull;
    }

    /**
     * Checks if a property is nullable
     *
     * @param string $property
     * @return bool
     */
    public static function isNullable(string $property): bool
    {
        return self::openAPINullables()[$property] ?? false;
    }

    /**
     * Checks if a nullable property is set to null.
     *
     * @param string $property
     * @return bool
     */
    public function isNullableSetToNull(string $property): bool
    {
        return in_array($property, $this->getOpenAPINullablesSetToNull(), true);
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'id' => 'id',
        'model' => 'model',
        'post_url' => 'post-url',
        'subscription_geo_support' => 'subscription-geo-support',
        'user_scope' => 'user-scope',
        'reseller' => 'reseller',
        'domain' => 'domain',
        'user' => 'user',
        'subscription_creation_datetime' => 'subscription-creation-datetime',
        'subscription_expires_datetime' => 'subscription-expires-datetime',
        'preferred_server' => 'preferred-server',
        'current_active_server' => 'current-active-server',
        'status' => 'status',
        'error_count' => 'error-count',
        'posts_count' => 'posts-count'
    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var string[]
     */
    protected static $setters = [
        'id' => 'setId',
        'model' => 'setModel',
        'post_url' => 'setPostUrl',
        'subscription_geo_support' => 'setSubscriptionGeoSupport',
        'user_scope' => 'setUserScope',
        'reseller' => 'setReseller',
        'domain' => 'setDomain',
        'user' => 'setUser',
        'subscription_creation_datetime' => 'setSubscriptionCreationDatetime',
        'subscription_expires_datetime' => 'setSubscriptionExpiresDatetime',
        'preferred_server' => 'setPreferredServer',
        'current_active_server' => 'setCurrentActiveServer',
        'status' => 'setStatus',
        'error_count' => 'setErrorCount',
        'posts_count' => 'setPostsCount'
    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var string[]
     */
    protected static $getters = [
        'id' => 'getId',
        'model' => 'getModel',
        'post_url' => 'getPostUrl',
        'subscription_geo_support' => 'getSubscriptionGeoSupport',
        'user_scope' => 'getUserScope',
        'reseller' => 'getReseller',
        'domain' => 'getDomain',
        'user' => 'getUser',
        'subscription_creation_datetime' => 'getSubscriptionCreationDatetime',
        'subscription_expires_datetime' => 'getSubscriptionExpiresDatetime',
        'preferred_server' => 'getPreferredServer',
        'current_active_server' => 'getCurrentActiveServer',
        'status' => 'getStatus',
        'error_count' => 'getErrorCount',
        'posts_count' => 'getPostsCount'
    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array
     */
    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array
     */
    public static function setters()
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array
     */
    public static function getters()
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName()
    {
        return self::$openAPIModelName;
    }

    public const MODEL_AGENT = 'agent';
    public const MODEL_AUDITLOG = 'auditlog';
    public const MODEL_AUDITLOG_LITE = 'auditlog_lite';
    public const MODEL_CALL = 'call';
    public const MODEL_CALL_ORIGID = 'call_origid';
    public const MODEL_CDR = 'cdr';
    public const MODEL_MESSAGE = 'message';
    public const MODEL_MESSAGESESSION = 'messagesession';
    public const MODEL_SUBSCRIBER = 'subscriber';
    public const MODEL_PRESENCE = 'presence';
    public const MODEL_VOICEMAIL = 'voicemail';
    public const STATUS_PENDING = 'pending';
    public const STATUS_ACTIVE = 'active';
    public const STATUS_ERROR = 'error';

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getModelAllowableValues()
    {
        return [
            self::MODEL_AGENT,
            self::MODEL_AUDITLOG,
            self::MODEL_AUDITLOG_LITE,
            self::MODEL_CALL,
            self::MODEL_CALL_ORIGID,
            self::MODEL_CDR,
            self::MODEL_MESSAGE,
            self::MODEL_MESSAGESESSION,
            self::MODEL_SUBSCRIBER,
            self::MODEL_PRESENCE,
            self::MODEL_VOICEMAIL,
        ];
    }

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getStatusAllowableValues()
    {
        return [
            self::STATUS_PENDING,
            self::STATUS_ACTIVE,
            self::STATUS_ERROR,
        ];
    }

    /**
     * Associative array for storing property values
     *
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     *
     * @param mixed[] $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(array $data = null)
    {
        $this->setIfExists('id', $data ?? [], null);
        $this->setIfExists('model', $data ?? [], null);
        $this->setIfExists('post_url', $data ?? [], null);
        $this->setIfExists('subscription_geo_support', $data ?? [], null);
        $this->setIfExists('user_scope', $data ?? [], null);
        $this->setIfExists('reseller', $data ?? [], null);
        $this->setIfExists('domain', $data ?? [], '*');
        $this->setIfExists('user', $data ?? [], '*');
        $this->setIfExists('subscription_creation_datetime', $data ?? [], null);
        $this->setIfExists('subscription_expires_datetime', $data ?? [], null);
        $this->setIfExists('preferred_server', $data ?? [], null);
        $this->setIfExists('current_active_server', $data ?? [], null);
        $this->setIfExists('status', $data ?? [], null);
        $this->setIfExists('error_count', $data ?? [], null);
        $this->setIfExists('posts_count', $data ?? [], null);
    }

    /**
    * Sets $this->container[$variableName] to the given data or to the given default Value; if $variableName
    * is nullable and its value is set to null in the $fields array, then mark it as "set to null" in the
    * $this->openAPINullablesSetToNull array
    *
    * @param string $variableName
    * @param array  $fields
    * @param mixed  $defaultValue
    */
    private function setIfExists(string $variableName, array $fields, $defaultValue): void
    {
        if (self::isNullable($variableName) && array_key_exists($variableName, $fields) && is_null($fields[$variableName])) {
            $this->openAPINullablesSetToNull[] = $variableName;
        }

        $this->container[$variableName] = $fields[$variableName] ?? $defaultValue;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalidProperties = [];

        if ($this->container['id'] === null) {
            $invalidProperties[] = "'id' can't be null";
        }
        $allowedValues = $this->getModelAllowableValues();
        if (!is_null($this->container['model']) && !in_array($this->container['model'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'model', must be one of '%s'",
                $this->container['model'],
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getStatusAllowableValues();
        if (!is_null($this->container['status']) && !in_array($this->container['status'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'status', must be one of '%s'",
                $this->container['status'],
                implode("', '", $allowedValues)
            );
        }

        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {
        return count($this->listInvalidProperties()) === 0;
    }


    /**
     * Gets id
     *
     * @return string
     */
    public function getId()
    {
        return $this->container['id'];
    }

    /**
     * Sets id
     *
     * @param string $id This is the main subscription id. This will be needed to edit and delete the subscription.
     *
     * @return self
     */
    public function setId($id)
    {
        if (is_null($id)) {
            throw new \InvalidArgumentException('non-nullable id cannot be null');
        }
        $this->container['id'] = $id;

        return $this;
    }

    /**
     * Gets model
     *
     * @return string|null
     */
    public function getModel()
    {
        return $this->container['model'];
    }

    /**
     * Sets model
     *
     * @param string|null $model This is the type of data that will be sent. you will need to reqest multiple subscriptions if you want more than one model. Addtional details available in guide at https://docs.ns-api.com/docs/event-subscriptions-1
     *
     * @return self
     */
    public function setModel($model)
    {
        if (is_null($model)) {
            throw new \InvalidArgumentException('non-nullable model cannot be null');
        }
        $allowedValues = $this->getModelAllowableValues();
        if (!in_array($model, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'model', must be one of '%s'",
                    $model,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['model'] = $model;

        return $this;
    }

    /**
     * Gets post_url
     *
     * @return string|null
     */
    public function getPostUrl()
    {
        return $this->container['post_url'];
    }

    /**
     * Sets post_url
     *
     * @param string|null $post_url This is the url the API will be posting data to. Should be in the format including https://. Can make a custom port if needed and the URL should have a valid SSL certificate as well. Http:// is supproted but not ideal for production.
     *
     * @return self
     */
    public function setPostUrl($post_url)
    {
        if (is_null($post_url)) {
            throw new \InvalidArgumentException('non-nullable post_url cannot be null');
        }
        $this->container['post_url'] = $post_url;

        return $this;
    }

    /**
     * Gets subscription_geo_support
     *
     * @return \SpectrumVoip\\\\NetSapiens\Model\YesNoStringYesDefault|null
     */
    public function getSubscriptionGeoSupport()
    {
        return $this->container['subscription_geo_support'];
    }

    /**
     * Sets subscription_geo_support
     *
     * @param \SpectrumVoip\\\\NetSapiens\Model\YesNoStringYesDefault|null $subscription_geo_support When enabled this rule is available to be user though it may not be active as the timeframe might not match the current time or there could be other hihger priority timeframes.
     *
     * @return self
     */
    public function setSubscriptionGeoSupport($subscription_geo_support)
    {
        if (is_null($subscription_geo_support)) {
            throw new \InvalidArgumentException('non-nullable subscription_geo_support cannot be null');
        }
        $this->container['subscription_geo_support'] = $subscription_geo_support;

        return $this;
    }

    /**
     * Gets user_scope
     *
     * @return \SpectrumVoip\\\\NetSapiens\Model\Scopes|null
     */
    public function getUserScope()
    {
        return $this->container['user_scope'];
    }

    /**
     * Sets user_scope
     *
     * @param \SpectrumVoip\\\\NetSapiens\Model\Scopes|null $user_scope This is the scope that should be enforced in combination with the reseller, domain and user fields. it will be set using the scope used to create the subscription.
     *
     * @return self
     */
    public function setUserScope($user_scope)
    {
        if (is_null($user_scope)) {
            throw new \InvalidArgumentException('non-nullable user_scope cannot be null');
        }
        $this->container['user_scope'] = $user_scope;

        return $this;
    }

    /**
     * Gets reseller
     *
     * @return string|null
     */
    public function getReseller()
    {
        return $this->container['reseller'];
    }

    /**
     * Sets reseller
     *
     * @param string|null $reseller This is the reseller that the subscription will filter data for. * will be used for all resellers, but only valid with Super User scope on the request.
     *
     * @return self
     */
    public function setReseller($reseller)
    {
        if (is_null($reseller)) {
            throw new \InvalidArgumentException('non-nullable reseller cannot be null');
        }
        $this->container['reseller'] = $reseller;

        return $this;
    }

    /**
     * Gets domain
     *
     * @return string|null
     */
    public function getDomain()
    {
        return $this->container['domain'];
    }

    /**
     * Sets domain
     *
     * @param string|null $domain This is the domain that the subscription will filter data for. \"*\" will be used for all domains, but only valid with Super User scope
     *
     * @return self
     */
    public function setDomain($domain)
    {
        if (is_null($domain)) {
            throw new \InvalidArgumentException('non-nullable domain cannot be null');
        }
        $this->container['domain'] = $domain;

        return $this;
    }

    /**
     * Gets user
     *
     * @return string|null
     */
    public function getUser()
    {
        return $this->container['user'];
    }

    /**
     * Sets user
     *
     * @param string|null $user This is the user that the subscription will filter data for. * will be used for all users.
     *
     * @return self
     */
    public function setUser($user)
    {
        if (is_null($user)) {
            throw new \InvalidArgumentException('non-nullable user cannot be null');
        }
        $this->container['user'] = $user;

        return $this;
    }

    /**
     * Gets subscription_creation_datetime
     *
     * @return \DateTime|null
     */
    public function getSubscriptionCreationDatetime()
    {
        return $this->container['subscription_creation_datetime'];
    }

    /**
     * Sets subscription_creation_datetime
     *
     * @param \DateTime|null $subscription_creation_datetime This is a timestamp of creation of the event subscrtipion.
     *
     * @return self
     */
    public function setSubscriptionCreationDatetime($subscription_creation_datetime)
    {
        if (is_null($subscription_creation_datetime)) {
            throw new \InvalidArgumentException('non-nullable subscription_creation_datetime cannot be null');
        }
        $this->container['subscription_creation_datetime'] = $subscription_creation_datetime;

        return $this;
    }

    /**
     * Gets subscription_expires_datetime
     *
     * @return \DateTime|null
     */
    public function getSubscriptionExpiresDatetime()
    {
        return $this->container['subscription_expires_datetime'];
    }

    /**
     * Sets subscription_expires_datetime
     *
     * @param \DateTime|null $subscription_expires_datetime This timestamp in the format of YYYY-MM-DD HH:MM:SS will be with the subscription will expire. After it expires it will be removed after some amount of time. If left blank it will set the expires time to the expires time of the timed token used, if using a APIkey it will be 20 years from the creation date that it will set for the expires for the new subscription
     *
     * @return self
     */
    public function setSubscriptionExpiresDatetime($subscription_expires_datetime)
    {
        if (is_null($subscription_expires_datetime)) {
            throw new \InvalidArgumentException('non-nullable subscription_expires_datetime cannot be null');
        }
        $this->container['subscription_expires_datetime'] = $subscription_expires_datetime;

        return $this;
    }

    /**
     * Gets preferred_server
     *
     * @return string|null
     */
    public function getPreferredServer()
    {
        return $this->container['preferred_server'];
    }

    /**
     * Sets preferred_server
     *
     * @param string|null $preferred_server This is the server hostname for the prefered server for this subscription, meaning if this server is up and online it will be the one sending the events. It wil fail back to this servre after 60s of stability.
     *
     * @return self
     */
    public function setPreferredServer($preferred_server)
    {
        if (is_null($preferred_server)) {
            throw new \InvalidArgumentException('non-nullable preferred_server cannot be null');
        }
        $this->container['preferred_server'] = $preferred_server;

        return $this;
    }

    /**
     * Gets current_active_server
     *
     * @return string|null
     */
    public function getCurrentActiveServer()
    {
        return $this->container['current_active_server'];
    }

    /**
     * Sets current_active_server
     *
     * @param string|null $current_active_server This is the current server that is running this schedule. It will chagne only when a new server takes over and is a read only field.
     *
     * @return self
     */
    public function setCurrentActiveServer($current_active_server)
    {
        if (is_null($current_active_server)) {
            throw new \InvalidArgumentException('non-nullable current_active_server cannot be null');
        }
        $this->container['current_active_server'] = $current_active_server;

        return $this;
    }

    /**
     * Gets status
     *
     * @return string|null
     */
    public function getStatus()
    {
        return $this->container['status'];
    }

    /**
     * Sets status
     *
     * @param string|null $status This is the status of the schedule. A new schedule will get \"pending\" till it gets some data to send and once successfull it will go to \"active\". If any attempts get a error over a interval it will toggle this field to \"error\" and reset only once it gets a clean interval of posts.
     *
     * @return self
     */
    public function setStatus($status)
    {
        if (is_null($status)) {
            throw new \InvalidArgumentException('non-nullable status cannot be null');
        }
        $allowedValues = $this->getStatusAllowableValues();
        if (!in_array($status, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'status', must be one of '%s'",
                    $status,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['status'] = $status;

        return $this;
    }

    /**
     * Gets error_count
     *
     * @return int|null
     */
    public function getErrorCount()
    {
        return $this->container['error_count'];
    }

    /**
     * Sets error_count
     *
     * @param int|null $error_count This is the number of attempted post's that resulted in a error, either an inability to send to a server (network,dns, timeout, etc..) or a response code that is above a 302. This value can be \"reset\" by setting it to 0 in a update request, but only 0 is allowed value.
     *
     * @return self
     */
    public function setErrorCount($error_count)
    {
        if (is_null($error_count)) {
            throw new \InvalidArgumentException('non-nullable error_count cannot be null');
        }
        $this->container['error_count'] = $error_count;

        return $this;
    }

    /**
     * Gets posts_count
     *
     * @return int|null
     */
    public function getPostsCount()
    {
        return $this->container['posts_count'];
    }

    /**
     * Sets posts_count
     *
     * @param int|null $posts_count This is the number of attempted post's in this schedule. This includes error and success attempts. This value can be \"reset\" by setting it to 0 in a update request, but only 0 is allowed value.
     *
     * @return self
     */
    public function setPostsCount($posts_count)
    {
        if (is_null($posts_count)) {
            throw new \InvalidArgumentException('non-nullable posts_count cannot be null');
        }
        $this->container['posts_count'] = $posts_count;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer $offset Offset
     *
     * @return boolean
     */
    public function offsetExists($offset): bool
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer $offset Offset
     *
     * @return mixed|null
     */
    #[\ReturnTypeWillChange]
    public function offsetGet($offset)
    {
        return $this->container[$offset] ?? null;
    }

    /**
     * Sets value based on offset.
     *
     * @param int|null $offset Offset
     * @param mixed    $value  Value to be set
     *
     * @return void
     */
    public function offsetSet($offset, $value): void
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer $offset Offset
     *
     * @return void
     */
    public function offsetUnset($offset): void
    {
        unset($this->container[$offset]);
    }

    /**
     * Serializes the object to a value that can be serialized natively by json_encode().
     * @link https://www.php.net/manual/en/jsonserializable.jsonserialize.php
     *
     * @return mixed Returns data which can be serialized by json_encode(), which is a value
     * of any type other than a resource.
     */
    #[\ReturnTypeWillChange]
    public function jsonSerialize()
    {
       return ObjectSerializer::sanitizeForSerialization($this);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString()
    {
        return json_encode(
            ObjectSerializer::sanitizeForSerialization($this),
            JSON_PRETTY_PRINT
        );
    }

    /**
     * Gets a header-safe presentation of the object
     *
     * @return string
     */
    public function toHeaderValue()
    {
        return json_encode(ObjectSerializer::sanitizeForSerialization($this));
    }
}


