<?php
/**
 * CallQueue
 *
 * PHP version 7.4
 *
 * @category Class
 * @package  SpectrumVoip\\\\NetSapiens
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * NetSapiens API v2
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.10.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace SpectrumVoip\\\\NetSapiens\Model;

use \ArrayAccess;
use \SpectrumVoip\\\\NetSapiens\ObjectSerializer;

/**
 * CallQueue Class Doc Comment
 *
 * @category Class
 * @package  SpectrumVoip\\\\NetSapiens
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 * @implements \ArrayAccess<string, mixed>
 */
class CallQueue implements ModelInterface, ArrayAccess, \JsonSerializable
{
    public const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static $openAPIModelName = 'CallQueue';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $openAPITypes = [
        'callqueue' => 'string',
        'domain' => 'string',
        'description' => 'string',
        'callqueue_dispatch_type' => 'string',
        'callqueue_calculate_statistics' => '\SpectrumVoip\\\\NetSapiens\Model\YesNoString',
        'active_queued_calls_total_current' => 'int',
        'callqueue_agent_dispatch_timeout_seconds' => 'int',
        'callqueue_count_agents_available' => 'int',
        'callqueue_count_agents_total' => 'int',
        'callqueue_debug' => '\SpectrumVoip\\\\NetSapiens\Model\YesNoString',
        'callqueue_force_full_intro_playback' => '\SpectrumVoip\\\\NetSapiens\Model\YesNoString',
        'callqueue_max_callback_queueing_hours' => 'int',
        'callqueue_max_current_callers_to_accept_new_callers' => 'int',
        'callqueue_max_current_wait_to_accept_new_callers_seconds' => 'int',
        'callqueue_max_wait_timeout_minutes' => 'int',
        'callqueue_require_available_agents_to_accept_new_callers' => '\SpectrumVoip\\\\NetSapiens\Model\YesNoStringNoDefault',
        'callqueue_source_match' => 'string',
        'callqueue_sms_enable' => '\SpectrumVoip\\\\NetSapiens\Model\YesNoStringNoDefault',
        'recording_configuration' => '\SpectrumVoip\\\\NetSapiens\Model\RecordingConfiguration',
        'callqueue_sms_phrase_initiate_chat' => 'string',
        'callqueue_sms_phrase_initiate_success' => 'string',
        'callqueue_sms_phrase_initiation_fail_' => 'string',
        'callqueue_sms_phrase_no_agents_available' => 'string',
        'callqueue_sms_phrase_terminate_chat' => 'string',
        'callqueue_sms_phrase_terminate_success' => 'string',
        'callqueue_agent_auto_logout_after_missed' => '\SpectrumVoip\\\\NetSapiens\Model\YesNoStringNoDefault',
        'callqueue_sim_ring_1st_round' => 'int',
        'callqueue_sim_ring_increment' => 'int'
    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var string[]
      * @phpstan-var array<string, string|null>
      * @psalm-var array<string, string|null>
      */
    protected static $openAPIFormats = [
        'callqueue' => null,
        'domain' => null,
        'description' => null,
        'callqueue_dispatch_type' => null,
        'callqueue_calculate_statistics' => null,
        'active_queued_calls_total_current' => null,
        'callqueue_agent_dispatch_timeout_seconds' => null,
        'callqueue_count_agents_available' => null,
        'callqueue_count_agents_total' => null,
        'callqueue_debug' => null,
        'callqueue_force_full_intro_playback' => null,
        'callqueue_max_callback_queueing_hours' => null,
        'callqueue_max_current_callers_to_accept_new_callers' => null,
        'callqueue_max_current_wait_to_accept_new_callers_seconds' => null,
        'callqueue_max_wait_timeout_minutes' => null,
        'callqueue_require_available_agents_to_accept_new_callers' => null,
        'callqueue_source_match' => null,
        'callqueue_sms_enable' => null,
        'recording_configuration' => null,
        'callqueue_sms_phrase_initiate_chat' => null,
        'callqueue_sms_phrase_initiate_success' => null,
        'callqueue_sms_phrase_initiation_fail_' => null,
        'callqueue_sms_phrase_no_agents_available' => null,
        'callqueue_sms_phrase_terminate_chat' => null,
        'callqueue_sms_phrase_terminate_success' => null,
        'callqueue_agent_auto_logout_after_missed' => null,
        'callqueue_sim_ring_1st_round' => null,
        'callqueue_sim_ring_increment' => null
    ];

    /**
      * Array of nullable properties. Used for (de)serialization
      *
      * @var boolean[]
      */
    protected static array $openAPINullables = [
        'callqueue' => false,
        'domain' => false,
        'description' => false,
        'callqueue_dispatch_type' => false,
        'callqueue_calculate_statistics' => false,
        'active_queued_calls_total_current' => false,
        'callqueue_agent_dispatch_timeout_seconds' => false,
        'callqueue_count_agents_available' => false,
        'callqueue_count_agents_total' => false,
        'callqueue_debug' => false,
        'callqueue_force_full_intro_playback' => false,
        'callqueue_max_callback_queueing_hours' => false,
        'callqueue_max_current_callers_to_accept_new_callers' => false,
        'callqueue_max_current_wait_to_accept_new_callers_seconds' => false,
        'callqueue_max_wait_timeout_minutes' => false,
        'callqueue_require_available_agents_to_accept_new_callers' => false,
        'callqueue_source_match' => true,
        'callqueue_sms_enable' => false,
        'recording_configuration' => false,
        'callqueue_sms_phrase_initiate_chat' => true,
        'callqueue_sms_phrase_initiate_success' => true,
        'callqueue_sms_phrase_initiation_fail_' => true,
        'callqueue_sms_phrase_no_agents_available' => true,
        'callqueue_sms_phrase_terminate_chat' => true,
        'callqueue_sms_phrase_terminate_success' => true,
        'callqueue_agent_auto_logout_after_missed' => false,
        'callqueue_sim_ring_1st_round' => false,
        'callqueue_sim_ring_increment' => false
    ];

    /**
      * If a nullable field gets set to null, insert it here
      *
      * @var boolean[]
      */
    protected array $openAPINullablesSetToNull = [];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPITypes()
    {
        return self::$openAPITypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPIFormats()
    {
        return self::$openAPIFormats;
    }

    /**
     * Array of nullable properties
     *
     * @return array
     */
    protected static function openAPINullables(): array
    {
        return self::$openAPINullables;
    }

    /**
     * Array of nullable field names deliberately set to null
     *
     * @return boolean[]
     */
    private function getOpenAPINullablesSetToNull(): array
    {
        return $this->openAPINullablesSetToNull;
    }

    /**
     * Setter - Array of nullable field names deliberately set to null
     *
     * @param boolean[] $openAPINullablesSetToNull
     */
    private function setOpenAPINullablesSetToNull(array $openAPINullablesSetToNull): void
    {
        $this->openAPINullablesSetToNull = $openAPINullablesSetToNull;
    }

    /**
     * Checks if a property is nullable
     *
     * @param string $property
     * @return bool
     */
    public static function isNullable(string $property): bool
    {
        return self::openAPINullables()[$property] ?? false;
    }

    /**
     * Checks if a nullable property is set to null.
     *
     * @param string $property
     * @return bool
     */
    public function isNullableSetToNull(string $property): bool
    {
        return in_array($property, $this->getOpenAPINullablesSetToNull(), true);
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'callqueue' => 'callqueue',
        'domain' => 'domain',
        'description' => 'description',
        'callqueue_dispatch_type' => 'callqueue-dispatch-type',
        'callqueue_calculate_statistics' => 'callqueue-calculate-statistics',
        'active_queued_calls_total_current' => 'active-queued-calls-total-current',
        'callqueue_agent_dispatch_timeout_seconds' => 'callqueue-agent-dispatch-timeout-seconds',
        'callqueue_count_agents_available' => 'callqueue-count-agents-available',
        'callqueue_count_agents_total' => 'callqueue-count-agents-total',
        'callqueue_debug' => 'callqueue-debug',
        'callqueue_force_full_intro_playback' => 'callqueue-force-full-intro-playback',
        'callqueue_max_callback_queueing_hours' => 'callqueue-max-callback-queueing-hours',
        'callqueue_max_current_callers_to_accept_new_callers' => 'callqueue-max-current-callers-to-accept-new-callers',
        'callqueue_max_current_wait_to_accept_new_callers_seconds' => 'callqueue-max-current-wait-to-accept-new-callers-seconds',
        'callqueue_max_wait_timeout_minutes' => 'callqueue-max-wait-timeout-minutes',
        'callqueue_require_available_agents_to_accept_new_callers' => 'callqueue-require-available-agents-to-accept-new-callers',
        'callqueue_source_match' => 'callqueue-source-match',
        'callqueue_sms_enable' => 'callqueue-sms-enable',
        'recording_configuration' => 'recording-configuration',
        'callqueue_sms_phrase_initiate_chat' => 'callqueue-sms-phrase-initiate-chat',
        'callqueue_sms_phrase_initiate_success' => 'callqueue-sms-phrase-initiate-success',
        'callqueue_sms_phrase_initiation_fail_' => 'callqueue-sms-phrase-initiation-fail ',
        'callqueue_sms_phrase_no_agents_available' => 'callqueue-sms-phrase-no-agents-available',
        'callqueue_sms_phrase_terminate_chat' => 'callqueue-sms-phrase-terminate-chat',
        'callqueue_sms_phrase_terminate_success' => 'callqueue-sms-phrase-terminate-success',
        'callqueue_agent_auto_logout_after_missed' => 'callqueue-agent-auto-logout-after-missed',
        'callqueue_sim_ring_1st_round' => 'callqueue-sim-ring-1st-round',
        'callqueue_sim_ring_increment' => 'callqueue-sim-ring-increment'
    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var string[]
     */
    protected static $setters = [
        'callqueue' => 'setCallqueue',
        'domain' => 'setDomain',
        'description' => 'setDescription',
        'callqueue_dispatch_type' => 'setCallqueueDispatchType',
        'callqueue_calculate_statistics' => 'setCallqueueCalculateStatistics',
        'active_queued_calls_total_current' => 'setActiveQueuedCallsTotalCurrent',
        'callqueue_agent_dispatch_timeout_seconds' => 'setCallqueueAgentDispatchTimeoutSeconds',
        'callqueue_count_agents_available' => 'setCallqueueCountAgentsAvailable',
        'callqueue_count_agents_total' => 'setCallqueueCountAgentsTotal',
        'callqueue_debug' => 'setCallqueueDebug',
        'callqueue_force_full_intro_playback' => 'setCallqueueForceFullIntroPlayback',
        'callqueue_max_callback_queueing_hours' => 'setCallqueueMaxCallbackQueueingHours',
        'callqueue_max_current_callers_to_accept_new_callers' => 'setCallqueueMaxCurrentCallersToAcceptNewCallers',
        'callqueue_max_current_wait_to_accept_new_callers_seconds' => 'setCallqueueMaxCurrentWaitToAcceptNewCallersSeconds',
        'callqueue_max_wait_timeout_minutes' => 'setCallqueueMaxWaitTimeoutMinutes',
        'callqueue_require_available_agents_to_accept_new_callers' => 'setCallqueueRequireAvailableAgentsToAcceptNewCallers',
        'callqueue_source_match' => 'setCallqueueSourceMatch',
        'callqueue_sms_enable' => 'setCallqueueSmsEnable',
        'recording_configuration' => 'setRecordingConfiguration',
        'callqueue_sms_phrase_initiate_chat' => 'setCallqueueSmsPhraseInitiateChat',
        'callqueue_sms_phrase_initiate_success' => 'setCallqueueSmsPhraseInitiateSuccess',
        'callqueue_sms_phrase_initiation_fail_' => 'setCallqueueSmsPhraseInitiationFail',
        'callqueue_sms_phrase_no_agents_available' => 'setCallqueueSmsPhraseNoAgentsAvailable',
        'callqueue_sms_phrase_terminate_chat' => 'setCallqueueSmsPhraseTerminateChat',
        'callqueue_sms_phrase_terminate_success' => 'setCallqueueSmsPhraseTerminateSuccess',
        'callqueue_agent_auto_logout_after_missed' => 'setCallqueueAgentAutoLogoutAfterMissed',
        'callqueue_sim_ring_1st_round' => 'setCallqueueSimRing1stRound',
        'callqueue_sim_ring_increment' => 'setCallqueueSimRingIncrement'
    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var string[]
     */
    protected static $getters = [
        'callqueue' => 'getCallqueue',
        'domain' => 'getDomain',
        'description' => 'getDescription',
        'callqueue_dispatch_type' => 'getCallqueueDispatchType',
        'callqueue_calculate_statistics' => 'getCallqueueCalculateStatistics',
        'active_queued_calls_total_current' => 'getActiveQueuedCallsTotalCurrent',
        'callqueue_agent_dispatch_timeout_seconds' => 'getCallqueueAgentDispatchTimeoutSeconds',
        'callqueue_count_agents_available' => 'getCallqueueCountAgentsAvailable',
        'callqueue_count_agents_total' => 'getCallqueueCountAgentsTotal',
        'callqueue_debug' => 'getCallqueueDebug',
        'callqueue_force_full_intro_playback' => 'getCallqueueForceFullIntroPlayback',
        'callqueue_max_callback_queueing_hours' => 'getCallqueueMaxCallbackQueueingHours',
        'callqueue_max_current_callers_to_accept_new_callers' => 'getCallqueueMaxCurrentCallersToAcceptNewCallers',
        'callqueue_max_current_wait_to_accept_new_callers_seconds' => 'getCallqueueMaxCurrentWaitToAcceptNewCallersSeconds',
        'callqueue_max_wait_timeout_minutes' => 'getCallqueueMaxWaitTimeoutMinutes',
        'callqueue_require_available_agents_to_accept_new_callers' => 'getCallqueueRequireAvailableAgentsToAcceptNewCallers',
        'callqueue_source_match' => 'getCallqueueSourceMatch',
        'callqueue_sms_enable' => 'getCallqueueSmsEnable',
        'recording_configuration' => 'getRecordingConfiguration',
        'callqueue_sms_phrase_initiate_chat' => 'getCallqueueSmsPhraseInitiateChat',
        'callqueue_sms_phrase_initiate_success' => 'getCallqueueSmsPhraseInitiateSuccess',
        'callqueue_sms_phrase_initiation_fail_' => 'getCallqueueSmsPhraseInitiationFail',
        'callqueue_sms_phrase_no_agents_available' => 'getCallqueueSmsPhraseNoAgentsAvailable',
        'callqueue_sms_phrase_terminate_chat' => 'getCallqueueSmsPhraseTerminateChat',
        'callqueue_sms_phrase_terminate_success' => 'getCallqueueSmsPhraseTerminateSuccess',
        'callqueue_agent_auto_logout_after_missed' => 'getCallqueueAgentAutoLogoutAfterMissed',
        'callqueue_sim_ring_1st_round' => 'getCallqueueSimRing1stRound',
        'callqueue_sim_ring_increment' => 'getCallqueueSimRingIncrement'
    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array
     */
    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array
     */
    public static function setters()
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array
     */
    public static function getters()
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName()
    {
        return self::$openAPIModelName;
    }

    public const CALLQUEUE_DISPATCH_TYPE_ROUND_ROBIN = 'Round-robin';
    public const CALLQUEUE_DISPATCH_TYPE_TIERED_ROUND_ROBIN = 'Tiered Round-robin';
    public const CALLQUEUE_DISPATCH_TYPE_RING_ALL = 'Ring All';
    public const CALLQUEUE_DISPATCH_TYPE_LINEAR_CASCADE = 'Linear Cascade';
    public const CALLQUEUE_DISPATCH_TYPE_LINEAR_HUNT = 'Linear Hunt';
    public const CALLQUEUE_DISPATCH_TYPE_CALL_PARK = 'Call Park';

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getCallqueueDispatchTypeAllowableValues()
    {
        return [
            self::CALLQUEUE_DISPATCH_TYPE_ROUND_ROBIN,
            self::CALLQUEUE_DISPATCH_TYPE_TIERED_ROUND_ROBIN,
            self::CALLQUEUE_DISPATCH_TYPE_RING_ALL,
            self::CALLQUEUE_DISPATCH_TYPE_LINEAR_CASCADE,
            self::CALLQUEUE_DISPATCH_TYPE_LINEAR_HUNT,
            self::CALLQUEUE_DISPATCH_TYPE_CALL_PARK,
        ];
    }

    /**
     * Associative array for storing property values
     *
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     *
     * @param mixed[] $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(array $data = null)
    {
        $this->setIfExists('callqueue', $data ?? [], null);
        $this->setIfExists('domain', $data ?? [], null);
        $this->setIfExists('description', $data ?? [], null);
        $this->setIfExists('callqueue_dispatch_type', $data ?? [], null);
        $this->setIfExists('callqueue_calculate_statistics', $data ?? [], null);
        $this->setIfExists('active_queued_calls_total_current', $data ?? [], null);
        $this->setIfExists('callqueue_agent_dispatch_timeout_seconds', $data ?? [], null);
        $this->setIfExists('callqueue_count_agents_available', $data ?? [], null);
        $this->setIfExists('callqueue_count_agents_total', $data ?? [], null);
        $this->setIfExists('callqueue_debug', $data ?? [], null);
        $this->setIfExists('callqueue_force_full_intro_playback', $data ?? [], null);
        $this->setIfExists('callqueue_max_callback_queueing_hours', $data ?? [], 0);
        $this->setIfExists('callqueue_max_current_callers_to_accept_new_callers', $data ?? [], 0);
        $this->setIfExists('callqueue_max_current_wait_to_accept_new_callers_seconds', $data ?? [], 0);
        $this->setIfExists('callqueue_max_wait_timeout_minutes', $data ?? [], 0);
        $this->setIfExists('callqueue_require_available_agents_to_accept_new_callers', $data ?? [], null);
        $this->setIfExists('callqueue_source_match', $data ?? [], null);
        $this->setIfExists('callqueue_sms_enable', $data ?? [], null);
        $this->setIfExists('recording_configuration', $data ?? [], null);
        $this->setIfExists('callqueue_sms_phrase_initiate_chat', $data ?? [], null);
        $this->setIfExists('callqueue_sms_phrase_initiate_success', $data ?? [], null);
        $this->setIfExists('callqueue_sms_phrase_initiation_fail_', $data ?? [], null);
        $this->setIfExists('callqueue_sms_phrase_no_agents_available', $data ?? [], null);
        $this->setIfExists('callqueue_sms_phrase_terminate_chat', $data ?? [], null);
        $this->setIfExists('callqueue_sms_phrase_terminate_success', $data ?? [], null);
        $this->setIfExists('callqueue_agent_auto_logout_after_missed', $data ?? [], null);
        $this->setIfExists('callqueue_sim_ring_1st_round', $data ?? [], 0);
        $this->setIfExists('callqueue_sim_ring_increment', $data ?? [], 1);
    }

    /**
    * Sets $this->container[$variableName] to the given data or to the given default Value; if $variableName
    * is nullable and its value is set to null in the $fields array, then mark it as "set to null" in the
    * $this->openAPINullablesSetToNull array
    *
    * @param string $variableName
    * @param array  $fields
    * @param mixed  $defaultValue
    */
    private function setIfExists(string $variableName, array $fields, $defaultValue): void
    {
        if (self::isNullable($variableName) && array_key_exists($variableName, $fields) && is_null($fields[$variableName])) {
            $this->openAPINullablesSetToNull[] = $variableName;
        }

        $this->container[$variableName] = $fields[$variableName] ?? $defaultValue;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalidProperties = [];

        if ($this->container['callqueue'] === null) {
            $invalidProperties[] = "'callqueue' can't be null";
        }
        if ($this->container['domain'] === null) {
            $invalidProperties[] = "'domain' can't be null";
        }
        if ((mb_strlen($this->container['domain']) > 64)) {
            $invalidProperties[] = "invalid value for 'domain', the character length must be smaller than or equal to 64.";
        }

        if (!preg_match("/^[A-Za-z0-9._-]+|\\*/", $this->container['domain'])) {
            $invalidProperties[] = "invalid value for 'domain', must be conform to the pattern /^[A-Za-z0-9._-]+|\\*/.";
        }

        $allowedValues = $this->getCallqueueDispatchTypeAllowableValues();
        if (!is_null($this->container['callqueue_dispatch_type']) && !in_array($this->container['callqueue_dispatch_type'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'callqueue_dispatch_type', must be one of '%s'",
                $this->container['callqueue_dispatch_type'],
                implode("', '", $allowedValues)
            );
        }

        if (!is_null($this->container['callqueue_max_callback_queueing_hours']) && ($this->container['callqueue_max_callback_queueing_hours'] > 6)) {
            $invalidProperties[] = "invalid value for 'callqueue_max_callback_queueing_hours', must be smaller than or equal to 6.";
        }

        if (!is_null($this->container['callqueue_max_callback_queueing_hours']) && ($this->container['callqueue_max_callback_queueing_hours'] < 0)) {
            $invalidProperties[] = "invalid value for 'callqueue_max_callback_queueing_hours', must be bigger than or equal to 0.";
        }

        if (!is_null($this->container['callqueue_max_current_callers_to_accept_new_callers']) && ($this->container['callqueue_max_current_callers_to_accept_new_callers'] < 0)) {
            $invalidProperties[] = "invalid value for 'callqueue_max_current_callers_to_accept_new_callers', must be bigger than or equal to 0.";
        }

        if (!is_null($this->container['callqueue_max_current_wait_to_accept_new_callers_seconds']) && ($this->container['callqueue_max_current_wait_to_accept_new_callers_seconds'] < 0)) {
            $invalidProperties[] = "invalid value for 'callqueue_max_current_wait_to_accept_new_callers_seconds', must be bigger than or equal to 0.";
        }

        if (!is_null($this->container['callqueue_max_wait_timeout_minutes']) && ($this->container['callqueue_max_wait_timeout_minutes'] < 0)) {
            $invalidProperties[] = "invalid value for 'callqueue_max_wait_timeout_minutes', must be bigger than or equal to 0.";
        }

        if (!is_null($this->container['callqueue_sim_ring_1st_round']) && ($this->container['callqueue_sim_ring_1st_round'] > 99)) {
            $invalidProperties[] = "invalid value for 'callqueue_sim_ring_1st_round', must be smaller than or equal to 99.";
        }

        if (!is_null($this->container['callqueue_sim_ring_1st_round']) && ($this->container['callqueue_sim_ring_1st_round'] < 0)) {
            $invalidProperties[] = "invalid value for 'callqueue_sim_ring_1st_round', must be bigger than or equal to 0.";
        }

        if (!is_null($this->container['callqueue_sim_ring_increment']) && ($this->container['callqueue_sim_ring_increment'] > 99)) {
            $invalidProperties[] = "invalid value for 'callqueue_sim_ring_increment', must be smaller than or equal to 99.";
        }

        if (!is_null($this->container['callqueue_sim_ring_increment']) && ($this->container['callqueue_sim_ring_increment'] < 0)) {
            $invalidProperties[] = "invalid value for 'callqueue_sim_ring_increment', must be bigger than or equal to 0.";
        }

        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {
        return count($this->listInvalidProperties()) === 0;
    }


    /**
     * Gets callqueue
     *
     * @return string
     */
    public function getCallqueue()
    {
        return $this->container['callqueue'];
    }

    /**
     * Sets callqueue
     *
     * @param string $callqueue This is the main call queue extension which is the identifier for this call quieue.
     *
     * @return self
     */
    public function setCallqueue($callqueue)
    {
        if (is_null($callqueue)) {
            throw new \InvalidArgumentException('non-nullable callqueue cannot be null');
        }
        $this->container['callqueue'] = $callqueue;

        return $this;
    }

    /**
     * Gets domain
     *
     * @return string
     */
    public function getDomain()
    {
        return $this->container['domain'];
    }

    /**
     * Sets domain
     *
     * @param string $domain This is the main organization name. This is used to link resource to its group/tenant/organization/enterprise. ~ and * can be used alone in special cases to mean My Domain (~) and All Domains (\\*).
     *
     * @return self
     */
    public function setDomain($domain)
    {
        if (is_null($domain)) {
            throw new \InvalidArgumentException('non-nullable domain cannot be null');
        }
        if ((mb_strlen($domain) > 64)) {
            throw new \InvalidArgumentException('invalid length for $domain when calling CallQueue., must be smaller than or equal to 64.');
        }
        if ((!preg_match("/^[A-Za-z0-9._-]+|\\*/", ObjectSerializer::toString($domain)))) {
            throw new \InvalidArgumentException("invalid value for \$domain when calling CallQueue., must conform to the pattern /^[A-Za-z0-9._-]+|\\*/.");
        }

        $this->container['domain'] = $domain;

        return $this;
    }

    /**
     * Gets description
     *
     * @return string|null
     */
    public function getDescription()
    {
        return $this->container['description'];
    }

    /**
     * Sets description
     *
     * @param string|null $description This is a simple description of the callqueue which can be used to better explain the use or purpose of this call queue.
     *
     * @return self
     */
    public function setDescription($description)
    {
        if (is_null($description)) {
            throw new \InvalidArgumentException('non-nullable description cannot be null');
        }
        $this->container['description'] = $description;

        return $this;
    }

    /**
     * Gets callqueue_dispatch_type
     *
     * @return string|null
     */
    public function getCallqueueDispatchType()
    {
        return $this->container['callqueue_dispatch_type'];
    }

    /**
     * Sets callqueue_dispatch_type
     *
     * @param string|null $callqueue_dispatch_type This is the main dispatch type for hunting agents. The options are described below.  #Round-robin #Tiered Round-robin #Ring All #Linear Cascade #Linear Hunt #Call Park
     *
     * @return self
     */
    public function setCallqueueDispatchType($callqueue_dispatch_type)
    {
        if (is_null($callqueue_dispatch_type)) {
            throw new \InvalidArgumentException('non-nullable callqueue_dispatch_type cannot be null');
        }
        $allowedValues = $this->getCallqueueDispatchTypeAllowableValues();
        if (!in_array($callqueue_dispatch_type, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'callqueue_dispatch_type', must be one of '%s'",
                    $callqueue_dispatch_type,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['callqueue_dispatch_type'] = $callqueue_dispatch_type;

        return $this;
    }

    /**
     * Gets callqueue_calculate_statistics
     *
     * @return \SpectrumVoip\\\\NetSapiens\Model\YesNoString|null
     */
    public function getCallqueueCalculateStatistics()
    {
        return $this->container['callqueue_calculate_statistics'];
    }

    /**
     * Sets callqueue_calculate_statistics
     *
     * @param \SpectrumVoip\\\\NetSapiens\Model\YesNoString|null $callqueue_calculate_statistics callqueue_calculate_statistics
     *
     * @return self
     */
    public function setCallqueueCalculateStatistics($callqueue_calculate_statistics)
    {
        if (is_null($callqueue_calculate_statistics)) {
            throw new \InvalidArgumentException('non-nullable callqueue_calculate_statistics cannot be null');
        }
        $this->container['callqueue_calculate_statistics'] = $callqueue_calculate_statistics;

        return $this;
    }

    /**
     * Gets active_queued_calls_total_current
     *
     * @return int|null
     */
    public function getActiveQueuedCallsTotalCurrent()
    {
        return $this->container['active_queued_calls_total_current'];
    }

    /**
     * Sets active_queued_calls_total_current
     *
     * @param int|null $active_queued_calls_total_current This is the current calls waiting in the call queue waiting to be dispatched.
     *
     * @return self
     */
    public function setActiveQueuedCallsTotalCurrent($active_queued_calls_total_current)
    {
        if (is_null($active_queued_calls_total_current)) {
            throw new \InvalidArgumentException('non-nullable active_queued_calls_total_current cannot be null');
        }
        $this->container['active_queued_calls_total_current'] = $active_queued_calls_total_current;

        return $this;
    }

    /**
     * Gets callqueue_agent_dispatch_timeout_seconds
     *
     * @return int|null
     */
    public function getCallqueueAgentDispatchTimeoutSeconds()
    {
        return $this->container['callqueue_agent_dispatch_timeout_seconds'];
    }

    /**
     * Sets callqueue_agent_dispatch_timeout_seconds
     *
     * @param int|null $callqueue_agent_dispatch_timeout_seconds This is the timeout in seconds the call queue will attempt an agent before timing out and retrying additional resources.
     *
     * @return self
     */
    public function setCallqueueAgentDispatchTimeoutSeconds($callqueue_agent_dispatch_timeout_seconds)
    {
        if (is_null($callqueue_agent_dispatch_timeout_seconds)) {
            throw new \InvalidArgumentException('non-nullable callqueue_agent_dispatch_timeout_seconds cannot be null');
        }
        $this->container['callqueue_agent_dispatch_timeout_seconds'] = $callqueue_agent_dispatch_timeout_seconds;

        return $this;
    }

    /**
     * Gets callqueue_count_agents_available
     *
     * @return int|null
     */
    public function getCallqueueCountAgentsAvailable()
    {
        return $this->container['callqueue_count_agents_available'];
    }

    /**
     * Sets callqueue_count_agents_available
     *
     * @param int|null $callqueue_count_agents_available This is the current number of agents logged in and available for work.
     *
     * @return self
     */
    public function setCallqueueCountAgentsAvailable($callqueue_count_agents_available)
    {
        if (is_null($callqueue_count_agents_available)) {
            throw new \InvalidArgumentException('non-nullable callqueue_count_agents_available cannot be null');
        }
        $this->container['callqueue_count_agents_available'] = $callqueue_count_agents_available;

        return $this;
    }

    /**
     * Gets callqueue_count_agents_total
     *
     * @return int|null
     */
    public function getCallqueueCountAgentsTotal()
    {
        return $this->container['callqueue_count_agents_total'];
    }

    /**
     * Sets callqueue_count_agents_total
     *
     * @param int|null $callqueue_count_agents_total This is the current number of agents configured for this callqueue.
     *
     * @return self
     */
    public function setCallqueueCountAgentsTotal($callqueue_count_agents_total)
    {
        if (is_null($callqueue_count_agents_total)) {
            throw new \InvalidArgumentException('non-nullable callqueue_count_agents_total cannot be null');
        }
        $this->container['callqueue_count_agents_total'] = $callqueue_count_agents_total;

        return $this;
    }

    /**
     * Gets callqueue_debug
     *
     * @return \SpectrumVoip\\\\NetSapiens\Model\YesNoString|null
     */
    public function getCallqueueDebug()
    {
        return $this->container['callqueue_debug'];
    }

    /**
     * Sets callqueue_debug
     *
     * @param \SpectrumVoip\\\\NetSapiens\Model\YesNoString|null $callqueue_debug callqueue_debug
     *
     * @return self
     */
    public function setCallqueueDebug($callqueue_debug)
    {
        if (is_null($callqueue_debug)) {
            throw new \InvalidArgumentException('non-nullable callqueue_debug cannot be null');
        }
        $this->container['callqueue_debug'] = $callqueue_debug;

        return $this;
    }

    /**
     * Gets callqueue_force_full_intro_playback
     *
     * @return \SpectrumVoip\\\\NetSapiens\Model\YesNoString|null
     */
    public function getCallqueueForceFullIntroPlayback()
    {
        return $this->container['callqueue_force_full_intro_playback'];
    }

    /**
     * Sets callqueue_force_full_intro_playback
     *
     * @param \SpectrumVoip\\\\NetSapiens\Model\YesNoString|null $callqueue_force_full_intro_playback callqueue_force_full_intro_playback
     *
     * @return self
     */
    public function setCallqueueForceFullIntroPlayback($callqueue_force_full_intro_playback)
    {
        if (is_null($callqueue_force_full_intro_playback)) {
            throw new \InvalidArgumentException('non-nullable callqueue_force_full_intro_playback cannot be null');
        }
        $this->container['callqueue_force_full_intro_playback'] = $callqueue_force_full_intro_playback;

        return $this;
    }

    /**
     * Gets callqueue_max_callback_queueing_hours
     *
     * @return int|null
     */
    public function getCallqueueMaxCallbackQueueingHours()
    {
        return $this->container['callqueue_max_callback_queueing_hours'];
    }

    /**
     * Sets callqueue_max_callback_queueing_hours
     *
     * @param int|null $callqueue_max_callback_queueing_hours This setting will allow callback's in the callqueue allowing callers to press a buton and opt for a callback instead of waiting. 0 the default is off, any other positive number will enable callback and allow callback up to that many hours after the callback is requested.
     *
     * @return self
     */
    public function setCallqueueMaxCallbackQueueingHours($callqueue_max_callback_queueing_hours)
    {
        if (is_null($callqueue_max_callback_queueing_hours)) {
            throw new \InvalidArgumentException('non-nullable callqueue_max_callback_queueing_hours cannot be null');
        }

        if (($callqueue_max_callback_queueing_hours > 6)) {
            throw new \InvalidArgumentException('invalid value for $callqueue_max_callback_queueing_hours when calling CallQueue., must be smaller than or equal to 6.');
        }
        if (($callqueue_max_callback_queueing_hours < 0)) {
            throw new \InvalidArgumentException('invalid value for $callqueue_max_callback_queueing_hours when calling CallQueue., must be bigger than or equal to 0.');
        }

        $this->container['callqueue_max_callback_queueing_hours'] = $callqueue_max_callback_queueing_hours;

        return $this;
    }

    /**
     * Gets callqueue_max_current_callers_to_accept_new_callers
     *
     * @return int|null
     */
    public function getCallqueueMaxCurrentCallersToAcceptNewCallers()
    {
        return $this->container['callqueue_max_current_callers_to_accept_new_callers'];
    }

    /**
     * Sets callqueue_max_current_callers_to_accept_new_callers
     *
     * @param int|null $callqueue_max_current_callers_to_accept_new_callers This setting is the maximum number of callers allowed in the queue before forward busy answer rules will be followed. 0 is unlimited
     *
     * @return self
     */
    public function setCallqueueMaxCurrentCallersToAcceptNewCallers($callqueue_max_current_callers_to_accept_new_callers)
    {
        if (is_null($callqueue_max_current_callers_to_accept_new_callers)) {
            throw new \InvalidArgumentException('non-nullable callqueue_max_current_callers_to_accept_new_callers cannot be null');
        }

        if (($callqueue_max_current_callers_to_accept_new_callers < 0)) {
            throw new \InvalidArgumentException('invalid value for $callqueue_max_current_callers_to_accept_new_callers when calling CallQueue., must be bigger than or equal to 0.');
        }

        $this->container['callqueue_max_current_callers_to_accept_new_callers'] = $callqueue_max_current_callers_to_accept_new_callers;

        return $this;
    }

    /**
     * Gets callqueue_max_current_wait_to_accept_new_callers_seconds
     *
     * @return int|null
     */
    public function getCallqueueMaxCurrentWaitToAcceptNewCallersSeconds()
    {
        return $this->container['callqueue_max_current_wait_to_accept_new_callers_seconds'];
    }

    /**
     * Sets callqueue_max_current_wait_to_accept_new_callers_seconds
     *
     * @param int|null $callqueue_max_current_wait_to_accept_new_callers_seconds This setting is the maximum expected wait time  allowed in the queue before forward busy answer rules will be followed. 0 is unlimited
     *
     * @return self
     */
    public function setCallqueueMaxCurrentWaitToAcceptNewCallersSeconds($callqueue_max_current_wait_to_accept_new_callers_seconds)
    {
        if (is_null($callqueue_max_current_wait_to_accept_new_callers_seconds)) {
            throw new \InvalidArgumentException('non-nullable callqueue_max_current_wait_to_accept_new_callers_seconds cannot be null');
        }

        if (($callqueue_max_current_wait_to_accept_new_callers_seconds < 0)) {
            throw new \InvalidArgumentException('invalid value for $callqueue_max_current_wait_to_accept_new_callers_seconds when calling CallQueue., must be bigger than or equal to 0.');
        }

        $this->container['callqueue_max_current_wait_to_accept_new_callers_seconds'] = $callqueue_max_current_wait_to_accept_new_callers_seconds;

        return $this;
    }

    /**
     * Gets callqueue_max_wait_timeout_minutes
     *
     * @return int|null
     */
    public function getCallqueueMaxWaitTimeoutMinutes()
    {
        return $this->container['callqueue_max_wait_timeout_minutes'];
    }

    /**
     * Sets callqueue_max_wait_timeout_minutes
     *
     * @param int|null $callqueue_max_wait_timeout_minutes This is the max wait time in minutes that it would allow a call to wait before being forced out of the queue. 0 is unlimited
     *
     * @return self
     */
    public function setCallqueueMaxWaitTimeoutMinutes($callqueue_max_wait_timeout_minutes)
    {
        if (is_null($callqueue_max_wait_timeout_minutes)) {
            throw new \InvalidArgumentException('non-nullable callqueue_max_wait_timeout_minutes cannot be null');
        }

        if (($callqueue_max_wait_timeout_minutes < 0)) {
            throw new \InvalidArgumentException('invalid value for $callqueue_max_wait_timeout_minutes when calling CallQueue., must be bigger than or equal to 0.');
        }

        $this->container['callqueue_max_wait_timeout_minutes'] = $callqueue_max_wait_timeout_minutes;

        return $this;
    }

    /**
     * Gets callqueue_require_available_agents_to_accept_new_callers
     *
     * @return \SpectrumVoip\\\\NetSapiens\Model\YesNoStringNoDefault|null
     */
    public function getCallqueueRequireAvailableAgentsToAcceptNewCallers()
    {
        return $this->container['callqueue_require_available_agents_to_accept_new_callers'];
    }

    /**
     * Sets callqueue_require_available_agents_to_accept_new_callers
     *
     * @param \SpectrumVoip\\\\NetSapiens\Model\YesNoStringNoDefault|null $callqueue_require_available_agents_to_accept_new_callers This settings will control if the the parent feature is enabled.
     *
     * @return self
     */
    public function setCallqueueRequireAvailableAgentsToAcceptNewCallers($callqueue_require_available_agents_to_accept_new_callers)
    {
        if (is_null($callqueue_require_available_agents_to_accept_new_callers)) {
            throw new \InvalidArgumentException('non-nullable callqueue_require_available_agents_to_accept_new_callers cannot be null');
        }
        $this->container['callqueue_require_available_agents_to_accept_new_callers'] = $callqueue_require_available_agents_to_accept_new_callers;

        return $this;
    }

    /**
     * Gets callqueue_source_match
     *
     * @return string|null
     */
    public function getCallqueueSourceMatch()
    {
        return $this->container['callqueue_source_match'];
    }

    /**
     * Sets callqueue_source_match
     *
     * @param string|null $callqueue_source_match This is a optional setting that will control the source match for the forward dispatch leg of calls allowing if needed different matches to connecting devices when calls come through the queue.
     *
     * @return self
     */
    public function setCallqueueSourceMatch($callqueue_source_match)
    {
        if (is_null($callqueue_source_match)) {
            array_push($this->openAPINullablesSetToNull, 'callqueue_source_match');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('callqueue_source_match', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['callqueue_source_match'] = $callqueue_source_match;

        return $this;
    }

    /**
     * Gets callqueue_sms_enable
     *
     * @return \SpectrumVoip\\\\NetSapiens\Model\YesNoStringNoDefault|null
     */
    public function getCallqueueSmsEnable()
    {
        return $this->container['callqueue_sms_enable'];
    }

    /**
     * Sets callqueue_sms_enable
     *
     * @param \SpectrumVoip\\\\NetSapiens\Model\YesNoStringNoDefault|null $callqueue_sms_enable This settings will control if the the parent feature is enabled.
     *
     * @return self
     */
    public function setCallqueueSmsEnable($callqueue_sms_enable)
    {
        if (is_null($callqueue_sms_enable)) {
            throw new \InvalidArgumentException('non-nullable callqueue_sms_enable cannot be null');
        }
        $this->container['callqueue_sms_enable'] = $callqueue_sms_enable;

        return $this;
    }

    /**
     * Gets recording_configuration
     *
     * @return \SpectrumVoip\\\\NetSapiens\Model\RecordingConfiguration|null
     */
    public function getRecordingConfiguration()
    {
        return $this->container['recording_configuration'];
    }

    /**
     * Sets recording_configuration
     *
     * @param \SpectrumVoip\\\\NetSapiens\Model\RecordingConfiguration|null $recording_configuration recording_configuration
     *
     * @return self
     */
    public function setRecordingConfiguration($recording_configuration)
    {
        if (is_null($recording_configuration)) {
            throw new \InvalidArgumentException('non-nullable recording_configuration cannot be null');
        }
        $this->container['recording_configuration'] = $recording_configuration;

        return $this;
    }

    /**
     * Gets callqueue_sms_phrase_initiate_chat
     *
     * @return string|null
     */
    public function getCallqueueSmsPhraseInitiateChat()
    {
        return $this->container['callqueue_sms_phrase_initiate_chat'];
    }

    /**
     * Sets callqueue_sms_phrase_initiate_chat
     *
     * @param string|null $callqueue_sms_phrase_initiate_chat This is the keyword that will be the trigger for a new SMS queueing session
     *
     * @return self
     */
    public function setCallqueueSmsPhraseInitiateChat($callqueue_sms_phrase_initiate_chat)
    {
        if (is_null($callqueue_sms_phrase_initiate_chat)) {
            array_push($this->openAPINullablesSetToNull, 'callqueue_sms_phrase_initiate_chat');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('callqueue_sms_phrase_initiate_chat', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['callqueue_sms_phrase_initiate_chat'] = $callqueue_sms_phrase_initiate_chat;

        return $this;
    }

    /**
     * Gets callqueue_sms_phrase_initiate_success
     *
     * @return string|null
     */
    public function getCallqueueSmsPhraseInitiateSuccess()
    {
        return $this->container['callqueue_sms_phrase_initiate_success'];
    }

    /**
     * Sets callqueue_sms_phrase_initiate_success
     *
     * @param string|null $callqueue_sms_phrase_initiate_success The message to auto reply to a inbound SMS message once the trigger keyword is detected
     *
     * @return self
     */
    public function setCallqueueSmsPhraseInitiateSuccess($callqueue_sms_phrase_initiate_success)
    {
        if (is_null($callqueue_sms_phrase_initiate_success)) {
            array_push($this->openAPINullablesSetToNull, 'callqueue_sms_phrase_initiate_success');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('callqueue_sms_phrase_initiate_success', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['callqueue_sms_phrase_initiate_success'] = $callqueue_sms_phrase_initiate_success;

        return $this;
    }

    /**
     * Gets callqueue_sms_phrase_initiation_fail_
     *
     * @return string|null
     */
    public function getCallqueueSmsPhraseInitiationFail()
    {
        return $this->container['callqueue_sms_phrase_initiation_fail_'];
    }

    /**
     * Sets callqueue_sms_phrase_initiation_fail_
     *
     * @param string|null $callqueue_sms_phrase_initiation_fail_ The message that will be auto replied when a message wihtout the keywork is detected.
     *
     * @return self
     */
    public function setCallqueueSmsPhraseInitiationFail($callqueue_sms_phrase_initiation_fail_)
    {
        if (is_null($callqueue_sms_phrase_initiation_fail_)) {
            array_push($this->openAPINullablesSetToNull, 'callqueue_sms_phrase_initiation_fail_');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('callqueue_sms_phrase_initiation_fail_', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['callqueue_sms_phrase_initiation_fail_'] = $callqueue_sms_phrase_initiation_fail_;

        return $this;
    }

    /**
     * Gets callqueue_sms_phrase_no_agents_available
     *
     * @return string|null
     */
    public function getCallqueueSmsPhraseNoAgentsAvailable()
    {
        return $this->container['callqueue_sms_phrase_no_agents_available'];
    }

    /**
     * Sets callqueue_sms_phrase_no_agents_available
     *
     * @param string|null $callqueue_sms_phrase_no_agents_available The message that will be auto replied when there are no agents available and the system is unable to setup a sms chat session at this time.
     *
     * @return self
     */
    public function setCallqueueSmsPhraseNoAgentsAvailable($callqueue_sms_phrase_no_agents_available)
    {
        if (is_null($callqueue_sms_phrase_no_agents_available)) {
            array_push($this->openAPINullablesSetToNull, 'callqueue_sms_phrase_no_agents_available');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('callqueue_sms_phrase_no_agents_available', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['callqueue_sms_phrase_no_agents_available'] = $callqueue_sms_phrase_no_agents_available;

        return $this;
    }

    /**
     * Gets callqueue_sms_phrase_terminate_chat
     *
     * @return string|null
     */
    public function getCallqueueSmsPhraseTerminateChat()
    {
        return $this->container['callqueue_sms_phrase_terminate_chat'];
    }

    /**
     * Sets callqueue_sms_phrase_terminate_chat
     *
     * @param string|null $callqueue_sms_phrase_terminate_chat This is the keyword that will be the trigger to end a active SMS session.
     *
     * @return self
     */
    public function setCallqueueSmsPhraseTerminateChat($callqueue_sms_phrase_terminate_chat)
    {
        if (is_null($callqueue_sms_phrase_terminate_chat)) {
            array_push($this->openAPINullablesSetToNull, 'callqueue_sms_phrase_terminate_chat');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('callqueue_sms_phrase_terminate_chat', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['callqueue_sms_phrase_terminate_chat'] = $callqueue_sms_phrase_terminate_chat;

        return $this;
    }

    /**
     * Gets callqueue_sms_phrase_terminate_success
     *
     * @return string|null
     */
    public function getCallqueueSmsPhraseTerminateSuccess()
    {
        return $this->container['callqueue_sms_phrase_terminate_success'];
    }

    /**
     * Sets callqueue_sms_phrase_terminate_success
     *
     * @param string|null $callqueue_sms_phrase_terminate_success The message that will be played after a successfully termination of a session via a keyword.
     *
     * @return self
     */
    public function setCallqueueSmsPhraseTerminateSuccess($callqueue_sms_phrase_terminate_success)
    {
        if (is_null($callqueue_sms_phrase_terminate_success)) {
            array_push($this->openAPINullablesSetToNull, 'callqueue_sms_phrase_terminate_success');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('callqueue_sms_phrase_terminate_success', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['callqueue_sms_phrase_terminate_success'] = $callqueue_sms_phrase_terminate_success;

        return $this;
    }

    /**
     * Gets callqueue_agent_auto_logout_after_missed
     *
     * @return \SpectrumVoip\\\\NetSapiens\Model\YesNoStringNoDefault|null
     */
    public function getCallqueueAgentAutoLogoutAfterMissed()
    {
        return $this->container['callqueue_agent_auto_logout_after_missed'];
    }

    /**
     * Sets callqueue_agent_auto_logout_after_missed
     *
     * @param \SpectrumVoip\\\\NetSapiens\Model\YesNoStringNoDefault|null $callqueue_agent_auto_logout_after_missed This settings will control if the the parent feature is enabled.
     *
     * @return self
     */
    public function setCallqueueAgentAutoLogoutAfterMissed($callqueue_agent_auto_logout_after_missed)
    {
        if (is_null($callqueue_agent_auto_logout_after_missed)) {
            throw new \InvalidArgumentException('non-nullable callqueue_agent_auto_logout_after_missed cannot be null');
        }
        $this->container['callqueue_agent_auto_logout_after_missed'] = $callqueue_agent_auto_logout_after_missed;

        return $this;
    }

    /**
     * Gets callqueue_sim_ring_1st_round
     *
     * @return int|null
     */
    public function getCallqueueSimRing1stRound()
    {
        return $this->container['callqueue_sim_ring_1st_round'];
    }

    /**
     * Sets callqueue_sim_ring_1st_round
     *
     * @param int|null $callqueue_sim_ring_1st_round When using a callqueue-dispatch-type value that allows for mutlple agents to be run on at a time this setting controls the amount of agents that are dispatched in the first round.
     *
     * @return self
     */
    public function setCallqueueSimRing1stRound($callqueue_sim_ring_1st_round)
    {
        if (is_null($callqueue_sim_ring_1st_round)) {
            throw new \InvalidArgumentException('non-nullable callqueue_sim_ring_1st_round cannot be null');
        }

        if (($callqueue_sim_ring_1st_round > 99)) {
            throw new \InvalidArgumentException('invalid value for $callqueue_sim_ring_1st_round when calling CallQueue., must be smaller than or equal to 99.');
        }
        if (($callqueue_sim_ring_1st_round < 0)) {
            throw new \InvalidArgumentException('invalid value for $callqueue_sim_ring_1st_round when calling CallQueue., must be bigger than or equal to 0.');
        }

        $this->container['callqueue_sim_ring_1st_round'] = $callqueue_sim_ring_1st_round;

        return $this;
    }

    /**
     * Gets callqueue_sim_ring_increment
     *
     * @return int|null
     */
    public function getCallqueueSimRingIncrement()
    {
        return $this->container['callqueue_sim_ring_increment'];
    }

    /**
     * Sets callqueue_sim_ring_increment
     *
     * @param int|null $callqueue_sim_ring_increment When using a callqueue-dispatch-type value that allows for mutlple agents to be run on at a time this setting controls the amount of agents that will be added to the group activly ringing at each agent timeout level.
     *
     * @return self
     */
    public function setCallqueueSimRingIncrement($callqueue_sim_ring_increment)
    {
        if (is_null($callqueue_sim_ring_increment)) {
            throw new \InvalidArgumentException('non-nullable callqueue_sim_ring_increment cannot be null');
        }

        if (($callqueue_sim_ring_increment > 99)) {
            throw new \InvalidArgumentException('invalid value for $callqueue_sim_ring_increment when calling CallQueue., must be smaller than or equal to 99.');
        }
        if (($callqueue_sim_ring_increment < 0)) {
            throw new \InvalidArgumentException('invalid value for $callqueue_sim_ring_increment when calling CallQueue., must be bigger than or equal to 0.');
        }

        $this->container['callqueue_sim_ring_increment'] = $callqueue_sim_ring_increment;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer $offset Offset
     *
     * @return boolean
     */
    public function offsetExists($offset): bool
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer $offset Offset
     *
     * @return mixed|null
     */
    #[\ReturnTypeWillChange]
    public function offsetGet($offset)
    {
        return $this->container[$offset] ?? null;
    }

    /**
     * Sets value based on offset.
     *
     * @param int|null $offset Offset
     * @param mixed    $value  Value to be set
     *
     * @return void
     */
    public function offsetSet($offset, $value): void
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer $offset Offset
     *
     * @return void
     */
    public function offsetUnset($offset): void
    {
        unset($this->container[$offset]);
    }

    /**
     * Serializes the object to a value that can be serialized natively by json_encode().
     * @link https://www.php.net/manual/en/jsonserializable.jsonserialize.php
     *
     * @return mixed Returns data which can be serialized by json_encode(), which is a value
     * of any type other than a resource.
     */
    #[\ReturnTypeWillChange]
    public function jsonSerialize()
    {
       return ObjectSerializer::sanitizeForSerialization($this);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString()
    {
        return json_encode(
            ObjectSerializer::sanitizeForSerialization($this),
            JSON_PRETTY_PRINT
        );
    }

    /**
     * Gets a header-safe presentation of the object
     *
     * @return string
     */
    public function toHeaderValue()
    {
        return json_encode(ObjectSerializer::sanitizeForSerialization($this));
    }
}


