<?php
/**
 * DomainsDomainUsersUserCallsPostRequest
 *
 * PHP version 7.4
 *
 * @category Class
 * @package  SpectrumVoip\\\\NetSapiens
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * NetSapiens API v2
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.10.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace SpectrumVoip\\\\NetSapiens\Model;

use \ArrayAccess;
use \SpectrumVoip\\\\NetSapiens\ObjectSerializer;

/**
 * DomainsDomainUsersUserCallsPostRequest Class Doc Comment
 *
 * @category Class
 * @package  SpectrumVoip\\\\NetSapiens
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 * @implements \ArrayAccess<string, mixed>
 */
class DomainsDomainUsersUserCallsPostRequest implements ModelInterface, ArrayAccess, \JsonSerializable
{
    public const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static $openAPIModelName = '_domains__domain__users__user__calls_post_request';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $openAPITypes = [
        'synchronous' => '\SpectrumVoip\\\\NetSapiens\Model\Synchronous',
        'call_id' => 'string',
        'dial_rule_application' => 'string',
        'call_term_user' => 'string',
        'call_orig_user' => 'string',
        'auto_answer_enabled' => 'string',
        'caller_id_number' => 'string',
        'callback_caller_id_number' => 'string'
    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var string[]
      * @phpstan-var array<string, string|null>
      * @psalm-var array<string, string|null>
      */
    protected static $openAPIFormats = [
        'synchronous' => null,
        'call_id' => null,
        'dial_rule_application' => null,
        'call_term_user' => null,
        'call_orig_user' => null,
        'auto_answer_enabled' => null,
        'caller_id_number' => null,
        'callback_caller_id_number' => null
    ];

    /**
      * Array of nullable properties. Used for (de)serialization
      *
      * @var boolean[]
      */
    protected static array $openAPINullables = [
        'synchronous' => false,
        'call_id' => false,
        'dial_rule_application' => false,
        'call_term_user' => false,
        'call_orig_user' => false,
        'auto_answer_enabled' => false,
        'caller_id_number' => false,
        'callback_caller_id_number' => false
    ];

    /**
      * If a nullable field gets set to null, insert it here
      *
      * @var boolean[]
      */
    protected array $openAPINullablesSetToNull = [];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPITypes()
    {
        return self::$openAPITypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPIFormats()
    {
        return self::$openAPIFormats;
    }

    /**
     * Array of nullable properties
     *
     * @return array
     */
    protected static function openAPINullables(): array
    {
        return self::$openAPINullables;
    }

    /**
     * Array of nullable field names deliberately set to null
     *
     * @return boolean[]
     */
    private function getOpenAPINullablesSetToNull(): array
    {
        return $this->openAPINullablesSetToNull;
    }

    /**
     * Setter - Array of nullable field names deliberately set to null
     *
     * @param boolean[] $openAPINullablesSetToNull
     */
    private function setOpenAPINullablesSetToNull(array $openAPINullablesSetToNull): void
    {
        $this->openAPINullablesSetToNull = $openAPINullablesSetToNull;
    }

    /**
     * Checks if a property is nullable
     *
     * @param string $property
     * @return bool
     */
    public static function isNullable(string $property): bool
    {
        return self::openAPINullables()[$property] ?? false;
    }

    /**
     * Checks if a nullable property is set to null.
     *
     * @param string $property
     * @return bool
     */
    public function isNullableSetToNull(string $property): bool
    {
        return in_array($property, $this->getOpenAPINullablesSetToNull(), true);
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'synchronous' => 'synchronous',
        'call_id' => 'call-id',
        'dial_rule_application' => 'dial-rule-application',
        'call_term_user' => 'call-term-user',
        'call_orig_user' => 'call-orig-user',
        'auto_answer_enabled' => 'auto-answer-enabled',
        'caller_id_number' => 'caller-id-number',
        'callback_caller_id_number' => 'callback-caller-id-number'
    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var string[]
     */
    protected static $setters = [
        'synchronous' => 'setSynchronous',
        'call_id' => 'setCallId',
        'dial_rule_application' => 'setDialRuleApplication',
        'call_term_user' => 'setCallTermUser',
        'call_orig_user' => 'setCallOrigUser',
        'auto_answer_enabled' => 'setAutoAnswerEnabled',
        'caller_id_number' => 'setCallerIdNumber',
        'callback_caller_id_number' => 'setCallbackCallerIdNumber'
    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var string[]
     */
    protected static $getters = [
        'synchronous' => 'getSynchronous',
        'call_id' => 'getCallId',
        'dial_rule_application' => 'getDialRuleApplication',
        'call_term_user' => 'getCallTermUser',
        'call_orig_user' => 'getCallOrigUser',
        'auto_answer_enabled' => 'getAutoAnswerEnabled',
        'caller_id_number' => 'getCallerIdNumber',
        'callback_caller_id_number' => 'getCallbackCallerIdNumber'
    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array
     */
    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array
     */
    public static function setters()
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array
     */
    public static function getters()
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName()
    {
        return self::$openAPIModelName;
    }

    public const AUTO_ANSWER_ENABLED_YES = 'yes';
    public const AUTO_ANSWER_ENABLED_NO = 'no';

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getAutoAnswerEnabledAllowableValues()
    {
        return [
            self::AUTO_ANSWER_ENABLED_YES,
            self::AUTO_ANSWER_ENABLED_NO,
        ];
    }

    /**
     * Associative array for storing property values
     *
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     *
     * @param mixed[] $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(array $data = null)
    {
        $this->setIfExists('synchronous', $data ?? [], null);
        $this->setIfExists('call_id', $data ?? [], null);
        $this->setIfExists('dial_rule_application', $data ?? [], 'call');
        $this->setIfExists('call_term_user', $data ?? [], null);
        $this->setIfExists('call_orig_user', $data ?? [], 'user@domain');
        $this->setIfExists('auto_answer_enabled', $data ?? [], 'no');
        $this->setIfExists('caller_id_number', $data ?? [], null);
        $this->setIfExists('callback_caller_id_number', $data ?? [], null);
    }

    /**
    * Sets $this->container[$variableName] to the given data or to the given default Value; if $variableName
    * is nullable and its value is set to null in the $fields array, then mark it as "set to null" in the
    * $this->openAPINullablesSetToNull array
    *
    * @param string $variableName
    * @param array  $fields
    * @param mixed  $defaultValue
    */
    private function setIfExists(string $variableName, array $fields, $defaultValue): void
    {
        if (self::isNullable($variableName) && array_key_exists($variableName, $fields) && is_null($fields[$variableName])) {
            $this->openAPINullablesSetToNull[] = $variableName;
        }

        $this->container[$variableName] = $fields[$variableName] ?? $defaultValue;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalidProperties = [];

        if ($this->container['synchronous'] === null) {
            $invalidProperties[] = "'synchronous' can't be null";
        }
        if ($this->container['call_id'] === null) {
            $invalidProperties[] = "'call_id' can't be null";
        }
        if ($this->container['call_term_user'] === null) {
            $invalidProperties[] = "'call_term_user' can't be null";
        }
        $allowedValues = $this->getAutoAnswerEnabledAllowableValues();
        if (!is_null($this->container['auto_answer_enabled']) && !in_array($this->container['auto_answer_enabled'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'auto_answer_enabled', must be one of '%s'",
                $this->container['auto_answer_enabled'],
                implode("', '", $allowedValues)
            );
        }

        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {
        return count($this->listInvalidProperties()) === 0;
    }


    /**
     * Gets synchronous
     *
     * @return \SpectrumVoip\\\\NetSapiens\Model\Synchronous
     */
    public function getSynchronous()
    {
        return $this->container['synchronous'];
    }

    /**
     * Sets synchronous
     *
     * @param \SpectrumVoip\\\\NetSapiens\Model\Synchronous $synchronous synchronous
     *
     * @return self
     */
    public function setSynchronous($synchronous)
    {
        if (is_null($synchronous)) {
            throw new \InvalidArgumentException('non-nullable synchronous cannot be null');
        }
        $this->container['synchronous'] = $synchronous;

        return $this;
    }

    /**
     * Gets call_id
     *
     * @return string
     */
    public function getCallId()
    {
        return $this->container['call_id'];
    }

    /**
     * Sets call_id
     *
     * @param string $call_id This will be the callid for the requested call. This should be a random string generated by your application and stored if you want to read back the call later or end it.
     *
     * @return self
     */
    public function setCallId($call_id)
    {
        if (is_null($call_id)) {
            throw new \InvalidArgumentException('non-nullable call_id cannot be null');
        }
        $this->container['call_id'] = $call_id;

        return $this;
    }

    /**
     * Gets dial_rule_application
     *
     * @return string|null
     */
    public function getDialRuleApplication()
    {
        return $this->container['dial_rule_application'];
    }

    /**
     * Sets dial_rule_application
     *
     * @param string|null $dial_rule_application The application can be used to help with next destination selection.
     *
     * @return self
     */
    public function setDialRuleApplication($dial_rule_application)
    {
        if (is_null($dial_rule_application)) {
            throw new \InvalidArgumentException('non-nullable dial_rule_application cannot be null');
        }
        $this->container['dial_rule_application'] = $dial_rule_application;

        return $this;
    }

    /**
     * Gets call_term_user
     *
     * @return string
     */
    public function getCallTermUser()
    {
        return $this->container['call_term_user'];
    }

    /**
     * Sets call_term_user
     *
     * @param string $call_term_user This will be the destination or termination number for the call request. This will be used once the call is connected to the orgination number.
     *
     * @return self
     */
    public function setCallTermUser($call_term_user)
    {
        if (is_null($call_term_user)) {
            throw new \InvalidArgumentException('non-nullable call_term_user cannot be null');
        }
        $this->container['call_term_user'] = $call_term_user;

        return $this;
    }

    /**
     * Gets call_orig_user
     *
     * @return string|null
     */
    public function getCallOrigUser()
    {
        return $this->container['call_orig_user'];
    }

    /**
     * Sets call_orig_user
     *
     * @param string|null $call_orig_user This field will allow you to select the device, user or number the first leg of the call request will connect to. If left blank the origination will be the user@domain of the user making the request.
     *
     * @return self
     */
    public function setCallOrigUser($call_orig_user)
    {
        if (is_null($call_orig_user)) {
            throw new \InvalidArgumentException('non-nullable call_orig_user cannot be null');
        }
        $this->container['call_orig_user'] = $call_orig_user;

        return $this;
    }

    /**
     * Gets auto_answer_enabled
     *
     * @return string|null
     */
    public function getAutoAnswerEnabled()
    {
        return $this->container['auto_answer_enabled'];
    }

    /**
     * Sets auto_answer_enabled
     *
     * @param string|null $auto_answer_enabled If enabled it will request auto answer headers for the first leg (origination) of the call.
     *
     * @return self
     */
    public function setAutoAnswerEnabled($auto_answer_enabled)
    {
        if (is_null($auto_answer_enabled)) {
            throw new \InvalidArgumentException('non-nullable auto_answer_enabled cannot be null');
        }
        $allowedValues = $this->getAutoAnswerEnabledAllowableValues();
        if (!in_array($auto_answer_enabled, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'auto_answer_enabled', must be one of '%s'",
                    $auto_answer_enabled,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['auto_answer_enabled'] = $auto_answer_enabled;

        return $this;
    }

    /**
     * Gets caller_id_number
     *
     * @return string|null
     */
    public function getCallerIdNumber()
    {
        return $this->container['caller_id_number'];
    }

    /**
     * Sets caller_id_number
     *
     * @param string|null $caller_id_number This setting will allow for the callerid of the termination leg to be set, by default it will be the preconfigured callerid of the user making the request.
     *
     * @return self
     */
    public function setCallerIdNumber($caller_id_number)
    {
        if (is_null($caller_id_number)) {
            throw new \InvalidArgumentException('non-nullable caller_id_number cannot be null');
        }
        $this->container['caller_id_number'] = $caller_id_number;

        return $this;
    }

    /**
     * Gets callback_caller_id_number
     *
     * @return string|null
     */
    public function getCallbackCallerIdNumber()
    {
        return $this->container['callback_caller_id_number'];
    }

    /**
     * Sets callback_caller_id_number
     *
     * @param string|null $callback_caller_id_number This is the callerid that will be used when calling the first leg(callback) of the call request. If left empty it will default to the user's caller id.
     *
     * @return self
     */
    public function setCallbackCallerIdNumber($callback_caller_id_number)
    {
        if (is_null($callback_caller_id_number)) {
            throw new \InvalidArgumentException('non-nullable callback_caller_id_number cannot be null');
        }
        $this->container['callback_caller_id_number'] = $callback_caller_id_number;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer $offset Offset
     *
     * @return boolean
     */
    public function offsetExists($offset): bool
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer $offset Offset
     *
     * @return mixed|null
     */
    #[\ReturnTypeWillChange]
    public function offsetGet($offset)
    {
        return $this->container[$offset] ?? null;
    }

    /**
     * Sets value based on offset.
     *
     * @param int|null $offset Offset
     * @param mixed    $value  Value to be set
     *
     * @return void
     */
    public function offsetSet($offset, $value): void
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer $offset Offset
     *
     * @return void
     */
    public function offsetUnset($offset): void
    {
        unset($this->container[$offset]);
    }

    /**
     * Serializes the object to a value that can be serialized natively by json_encode().
     * @link https://www.php.net/manual/en/jsonserializable.jsonserialize.php
     *
     * @return mixed Returns data which can be serialized by json_encode(), which is a value
     * of any type other than a resource.
     */
    #[\ReturnTypeWillChange]
    public function jsonSerialize()
    {
       return ObjectSerializer::sanitizeForSerialization($this);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString()
    {
        return json_encode(
            ObjectSerializer::sanitizeForSerialization($this),
            JSON_PRETTY_PRINT
        );
    }

    /**
     * Gets a header-safe presentation of the object
     *
     * @return string
     */
    public function toHeaderValue()
    {
        return json_encode(ObjectSerializer::sanitizeForSerialization($this));
    }
}


