<?php
/**
 * CreateAgentRequest
 *
 * PHP version 7.4
 *
 * @category Class
 * @package  SpectrumVoip\\\\NetSapiens
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * NetSapiens API v2
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.10.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace SpectrumVoip\\\\NetSapiens\Model;

use \ArrayAccess;
use \SpectrumVoip\\\\NetSapiens\ObjectSerializer;

/**
 * CreateAgentRequest Class Doc Comment
 *
 * @category Class
 * @package  SpectrumVoip\\\\NetSapiens
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 * @implements \ArrayAccess<string, mixed>
 */
class CreateAgentRequest implements ModelInterface, ArrayAccess, \JsonSerializable
{
    public const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static $openAPIModelName = 'CreateAgent_request';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $openAPITypes = [
        'synchronous' => '\SpectrumVoip\\\\NetSapiens\Model\Synchronous',
        'callqueue_agent_id' => 'string',
        'callqueue' => 'string',
        'domain' => 'string',
        'callqueue_agent_availability_type' => 'string',
        'callqueue_agent_wrap_up_allowance_seconds' => 'int',
        'auto_answer_enabled' => '\SpectrumVoip\\\\NetSapiens\Model\YesNoStringNoDefault',
        'callqueue_agent_dispatch_order_ordinal' => 'int',
        'callqueue_agent_dispatch_queue_priority_ordinal' => 'int',
        'limits_max_active_calls_total' => 'int',
        'callqueue_agent_answer_confirmation_enabled' => '\SpectrumVoip\\\\NetSapiens\Model\YesNoStringNoDefault',
        'callqueue_agent_has_registered_devices' => 'string',
        'callqueue_agent_availability_for_dispatch' => 'string',
        'active_calls_total_current' => 'int',
        'last_modified_datetime' => '\DateTime',
        'callqueue_agent_max_concurrent_sms_conversations' => 'int',
        'last_callqueue_dispatch_datetime' => '\DateTime',
        'callqueue_agent_entry_type' => 'string',
        'login_username' => 'string',
        'name_full_name' => 'string',
        'agent_name_first_name' => 'string',
        'agent_name_last_name' => 'string',
        'agent_department' => 'string',
        'agent_site' => 'string',
        'agent_user_scope' => 'string',
        'agent_status_message' => 'string'
    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var string[]
      * @phpstan-var array<string, string|null>
      * @psalm-var array<string, string|null>
      */
    protected static $openAPIFormats = [
        'synchronous' => null,
        'callqueue_agent_id' => null,
        'callqueue' => null,
        'domain' => null,
        'callqueue_agent_availability_type' => null,
        'callqueue_agent_wrap_up_allowance_seconds' => null,
        'auto_answer_enabled' => null,
        'callqueue_agent_dispatch_order_ordinal' => null,
        'callqueue_agent_dispatch_queue_priority_ordinal' => null,
        'limits_max_active_calls_total' => null,
        'callqueue_agent_answer_confirmation_enabled' => null,
        'callqueue_agent_has_registered_devices' => null,
        'callqueue_agent_availability_for_dispatch' => null,
        'active_calls_total_current' => null,
        'last_modified_datetime' => 'date-time',
        'callqueue_agent_max_concurrent_sms_conversations' => null,
        'last_callqueue_dispatch_datetime' => 'date-time',
        'callqueue_agent_entry_type' => null,
        'login_username' => null,
        'name_full_name' => null,
        'agent_name_first_name' => null,
        'agent_name_last_name' => null,
        'agent_department' => null,
        'agent_site' => null,
        'agent_user_scope' => null,
        'agent_status_message' => null
    ];

    /**
      * Array of nullable properties. Used for (de)serialization
      *
      * @var boolean[]
      */
    protected static array $openAPINullables = [
        'synchronous' => false,
        'callqueue_agent_id' => false,
        'callqueue' => false,
        'domain' => false,
        'callqueue_agent_availability_type' => false,
        'callqueue_agent_wrap_up_allowance_seconds' => false,
        'auto_answer_enabled' => false,
        'callqueue_agent_dispatch_order_ordinal' => false,
        'callqueue_agent_dispatch_queue_priority_ordinal' => false,
        'limits_max_active_calls_total' => false,
        'callqueue_agent_answer_confirmation_enabled' => false,
        'callqueue_agent_has_registered_devices' => false,
        'callqueue_agent_availability_for_dispatch' => false,
        'active_calls_total_current' => false,
        'last_modified_datetime' => false,
        'callqueue_agent_max_concurrent_sms_conversations' => false,
        'last_callqueue_dispatch_datetime' => true,
        'callqueue_agent_entry_type' => false,
        'login_username' => false,
        'name_full_name' => false,
        'agent_name_first_name' => false,
        'agent_name_last_name' => false,
        'agent_department' => false,
        'agent_site' => false,
        'agent_user_scope' => false,
        'agent_status_message' => true
    ];

    /**
      * If a nullable field gets set to null, insert it here
      *
      * @var boolean[]
      */
    protected array $openAPINullablesSetToNull = [];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPITypes()
    {
        return self::$openAPITypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPIFormats()
    {
        return self::$openAPIFormats;
    }

    /**
     * Array of nullable properties
     *
     * @return array
     */
    protected static function openAPINullables(): array
    {
        return self::$openAPINullables;
    }

    /**
     * Array of nullable field names deliberately set to null
     *
     * @return boolean[]
     */
    private function getOpenAPINullablesSetToNull(): array
    {
        return $this->openAPINullablesSetToNull;
    }

    /**
     * Setter - Array of nullable field names deliberately set to null
     *
     * @param boolean[] $openAPINullablesSetToNull
     */
    private function setOpenAPINullablesSetToNull(array $openAPINullablesSetToNull): void
    {
        $this->openAPINullablesSetToNull = $openAPINullablesSetToNull;
    }

    /**
     * Checks if a property is nullable
     *
     * @param string $property
     * @return bool
     */
    public static function isNullable(string $property): bool
    {
        return self::openAPINullables()[$property] ?? false;
    }

    /**
     * Checks if a nullable property is set to null.
     *
     * @param string $property
     * @return bool
     */
    public function isNullableSetToNull(string $property): bool
    {
        return in_array($property, $this->getOpenAPINullablesSetToNull(), true);
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'synchronous' => 'synchronous',
        'callqueue_agent_id' => 'callqueue-agent-id',
        'callqueue' => 'callqueue',
        'domain' => 'domain',
        'callqueue_agent_availability_type' => 'callqueue-agent-availability-type',
        'callqueue_agent_wrap_up_allowance_seconds' => 'callqueue-agent-wrap-up-allowance-seconds',
        'auto_answer_enabled' => 'auto-answer-enabled',
        'callqueue_agent_dispatch_order_ordinal' => 'callqueue-agent-dispatch-order-ordinal',
        'callqueue_agent_dispatch_queue_priority_ordinal' => 'callqueue-agent-dispatch-queue-priority-ordinal',
        'limits_max_active_calls_total' => 'limits-max-active-calls-total',
        'callqueue_agent_answer_confirmation_enabled' => 'callqueue-agent-answer-confirmation-enabled',
        'callqueue_agent_has_registered_devices' => 'callqueue-agent-has-registered-devices',
        'callqueue_agent_availability_for_dispatch' => 'callqueue-agent-availability-for-dispatch',
        'active_calls_total_current' => 'active-calls-total-current',
        'last_modified_datetime' => 'last-modified-datetime',
        'callqueue_agent_max_concurrent_sms_conversations' => 'callqueue-agent-max-concurrent-sms-conversations',
        'last_callqueue_dispatch_datetime' => 'last-callqueue-dispatch-datetime',
        'callqueue_agent_entry_type' => 'callqueue-agent-entry-type',
        'login_username' => 'login-username',
        'name_full_name' => 'name-full-name',
        'agent_name_first_name' => 'agent-name-first-name',
        'agent_name_last_name' => 'agent-name-last-name',
        'agent_department' => 'agent-department',
        'agent_site' => 'agent-site',
        'agent_user_scope' => 'agent-user-scope',
        'agent_status_message' => 'agent-status-message'
    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var string[]
     */
    protected static $setters = [
        'synchronous' => 'setSynchronous',
        'callqueue_agent_id' => 'setCallqueueAgentId',
        'callqueue' => 'setCallqueue',
        'domain' => 'setDomain',
        'callqueue_agent_availability_type' => 'setCallqueueAgentAvailabilityType',
        'callqueue_agent_wrap_up_allowance_seconds' => 'setCallqueueAgentWrapUpAllowanceSeconds',
        'auto_answer_enabled' => 'setAutoAnswerEnabled',
        'callqueue_agent_dispatch_order_ordinal' => 'setCallqueueAgentDispatchOrderOrdinal',
        'callqueue_agent_dispatch_queue_priority_ordinal' => 'setCallqueueAgentDispatchQueuePriorityOrdinal',
        'limits_max_active_calls_total' => 'setLimitsMaxActiveCallsTotal',
        'callqueue_agent_answer_confirmation_enabled' => 'setCallqueueAgentAnswerConfirmationEnabled',
        'callqueue_agent_has_registered_devices' => 'setCallqueueAgentHasRegisteredDevices',
        'callqueue_agent_availability_for_dispatch' => 'setCallqueueAgentAvailabilityForDispatch',
        'active_calls_total_current' => 'setActiveCallsTotalCurrent',
        'last_modified_datetime' => 'setLastModifiedDatetime',
        'callqueue_agent_max_concurrent_sms_conversations' => 'setCallqueueAgentMaxConcurrentSmsConversations',
        'last_callqueue_dispatch_datetime' => 'setLastCallqueueDispatchDatetime',
        'callqueue_agent_entry_type' => 'setCallqueueAgentEntryType',
        'login_username' => 'setLoginUsername',
        'name_full_name' => 'setNameFullName',
        'agent_name_first_name' => 'setAgentNameFirstName',
        'agent_name_last_name' => 'setAgentNameLastName',
        'agent_department' => 'setAgentDepartment',
        'agent_site' => 'setAgentSite',
        'agent_user_scope' => 'setAgentUserScope',
        'agent_status_message' => 'setAgentStatusMessage'
    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var string[]
     */
    protected static $getters = [
        'synchronous' => 'getSynchronous',
        'callqueue_agent_id' => 'getCallqueueAgentId',
        'callqueue' => 'getCallqueue',
        'domain' => 'getDomain',
        'callqueue_agent_availability_type' => 'getCallqueueAgentAvailabilityType',
        'callqueue_agent_wrap_up_allowance_seconds' => 'getCallqueueAgentWrapUpAllowanceSeconds',
        'auto_answer_enabled' => 'getAutoAnswerEnabled',
        'callqueue_agent_dispatch_order_ordinal' => 'getCallqueueAgentDispatchOrderOrdinal',
        'callqueue_agent_dispatch_queue_priority_ordinal' => 'getCallqueueAgentDispatchQueuePriorityOrdinal',
        'limits_max_active_calls_total' => 'getLimitsMaxActiveCallsTotal',
        'callqueue_agent_answer_confirmation_enabled' => 'getCallqueueAgentAnswerConfirmationEnabled',
        'callqueue_agent_has_registered_devices' => 'getCallqueueAgentHasRegisteredDevices',
        'callqueue_agent_availability_for_dispatch' => 'getCallqueueAgentAvailabilityForDispatch',
        'active_calls_total_current' => 'getActiveCallsTotalCurrent',
        'last_modified_datetime' => 'getLastModifiedDatetime',
        'callqueue_agent_max_concurrent_sms_conversations' => 'getCallqueueAgentMaxConcurrentSmsConversations',
        'last_callqueue_dispatch_datetime' => 'getLastCallqueueDispatchDatetime',
        'callqueue_agent_entry_type' => 'getCallqueueAgentEntryType',
        'login_username' => 'getLoginUsername',
        'name_full_name' => 'getNameFullName',
        'agent_name_first_name' => 'getAgentNameFirstName',
        'agent_name_last_name' => 'getAgentNameLastName',
        'agent_department' => 'getAgentDepartment',
        'agent_site' => 'getAgentSite',
        'agent_user_scope' => 'getAgentUserScope',
        'agent_status_message' => 'getAgentStatusMessage'
    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array
     */
    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array
     */
    public static function setters()
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array
     */
    public static function getters()
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName()
    {
        return self::$openAPIModelName;
    }

    public const CALLQUEUE_AGENT_AVAILABILITY_TYPE_AUTOMATIC = 'automatic';
    public const CALLQUEUE_AGENT_AVAILABILITY_TYPE_MANUAL = 'manual';
    public const CALLQUEUE_AGENT_AVAILABILITY_TYPE_DISABLED = 'disabled';
    public const CALLQUEUE_AGENT_AVAILABILITY_TYPE_OFFNET_AUTOMATIC = 'offnet-automatic';
    public const CALLQUEUE_AGENT_HAS_REGISTERED_DEVICES_YES = 'yes';
    public const CALLQUEUE_AGENT_HAS_REGISTERED_DEVICES_NO = 'no';
    public const CALLQUEUE_AGENT_HAS_REGISTERED_DEVICES_PUSH_ENABLED = 'push-enabled';
    public const CALLQUEUE_AGENT_HAS_REGISTERED_DEVICES_OFFNET = 'offnet';
    public const CALLQUEUE_AGENT_ENTRY_TYPE_DEVICE = 'device';
    public const CALLQUEUE_AGENT_ENTRY_TYPE_USER = 'user';
    public const CALLQUEUE_AGENT_ENTRY_TYPE_OFFNET = 'offnet';

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getCallqueueAgentAvailabilityTypeAllowableValues()
    {
        return [
            self::CALLQUEUE_AGENT_AVAILABILITY_TYPE_AUTOMATIC,
            self::CALLQUEUE_AGENT_AVAILABILITY_TYPE_MANUAL,
            self::CALLQUEUE_AGENT_AVAILABILITY_TYPE_DISABLED,
            self::CALLQUEUE_AGENT_AVAILABILITY_TYPE_OFFNET_AUTOMATIC,
        ];
    }

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getCallqueueAgentHasRegisteredDevicesAllowableValues()
    {
        return [
            self::CALLQUEUE_AGENT_HAS_REGISTERED_DEVICES_YES,
            self::CALLQUEUE_AGENT_HAS_REGISTERED_DEVICES_NO,
            self::CALLQUEUE_AGENT_HAS_REGISTERED_DEVICES_PUSH_ENABLED,
            self::CALLQUEUE_AGENT_HAS_REGISTERED_DEVICES_OFFNET,
        ];
    }

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getCallqueueAgentEntryTypeAllowableValues()
    {
        return [
            self::CALLQUEUE_AGENT_ENTRY_TYPE_DEVICE,
            self::CALLQUEUE_AGENT_ENTRY_TYPE_USER,
            self::CALLQUEUE_AGENT_ENTRY_TYPE_OFFNET,
        ];
    }

    /**
     * Associative array for storing property values
     *
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     *
     * @param mixed[] $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(array $data = null)
    {
        $this->setIfExists('synchronous', $data ?? [], null);
        $this->setIfExists('callqueue_agent_id', $data ?? [], null);
        $this->setIfExists('callqueue', $data ?? [], null);
        $this->setIfExists('domain', $data ?? [], null);
        $this->setIfExists('callqueue_agent_availability_type', $data ?? [], null);
        $this->setIfExists('callqueue_agent_wrap_up_allowance_seconds', $data ?? [], 0);
        $this->setIfExists('auto_answer_enabled', $data ?? [], null);
        $this->setIfExists('callqueue_agent_dispatch_order_ordinal', $data ?? [], null);
        $this->setIfExists('callqueue_agent_dispatch_queue_priority_ordinal', $data ?? [], null);
        $this->setIfExists('limits_max_active_calls_total', $data ?? [], null);
        $this->setIfExists('callqueue_agent_answer_confirmation_enabled', $data ?? [], null);
        $this->setIfExists('callqueue_agent_has_registered_devices', $data ?? [], null);
        $this->setIfExists('callqueue_agent_availability_for_dispatch', $data ?? [], null);
        $this->setIfExists('active_calls_total_current', $data ?? [], null);
        $this->setIfExists('last_modified_datetime', $data ?? [], null);
        $this->setIfExists('callqueue_agent_max_concurrent_sms_conversations', $data ?? [], null);
        $this->setIfExists('last_callqueue_dispatch_datetime', $data ?? [], null);
        $this->setIfExists('callqueue_agent_entry_type', $data ?? [], null);
        $this->setIfExists('login_username', $data ?? [], null);
        $this->setIfExists('name_full_name', $data ?? [], null);
        $this->setIfExists('agent_name_first_name', $data ?? [], null);
        $this->setIfExists('agent_name_last_name', $data ?? [], null);
        $this->setIfExists('agent_department', $data ?? [], null);
        $this->setIfExists('agent_site', $data ?? [], null);
        $this->setIfExists('agent_user_scope', $data ?? [], null);
        $this->setIfExists('agent_status_message', $data ?? [], null);
    }

    /**
    * Sets $this->container[$variableName] to the given data or to the given default Value; if $variableName
    * is nullable and its value is set to null in the $fields array, then mark it as "set to null" in the
    * $this->openAPINullablesSetToNull array
    *
    * @param string $variableName
    * @param array  $fields
    * @param mixed  $defaultValue
    */
    private function setIfExists(string $variableName, array $fields, $defaultValue): void
    {
        if (self::isNullable($variableName) && array_key_exists($variableName, $fields) && is_null($fields[$variableName])) {
            $this->openAPINullablesSetToNull[] = $variableName;
        }

        $this->container[$variableName] = $fields[$variableName] ?? $defaultValue;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalidProperties = [];

        if ($this->container['callqueue_agent_id'] === null) {
            $invalidProperties[] = "'callqueue_agent_id' can't be null";
        }
        if (!is_null($this->container['domain']) && (mb_strlen($this->container['domain']) > 64)) {
            $invalidProperties[] = "invalid value for 'domain', the character length must be smaller than or equal to 64.";
        }

        if (!is_null($this->container['domain']) && !preg_match("/^[A-Za-z0-9._-]+|\\*/", $this->container['domain'])) {
            $invalidProperties[] = "invalid value for 'domain', must be conform to the pattern /^[A-Za-z0-9._-]+|\\*/.";
        }

        $allowedValues = $this->getCallqueueAgentAvailabilityTypeAllowableValues();
        if (!is_null($this->container['callqueue_agent_availability_type']) && !in_array($this->container['callqueue_agent_availability_type'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'callqueue_agent_availability_type', must be one of '%s'",
                $this->container['callqueue_agent_availability_type'],
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getCallqueueAgentHasRegisteredDevicesAllowableValues();
        if (!is_null($this->container['callqueue_agent_has_registered_devices']) && !in_array($this->container['callqueue_agent_has_registered_devices'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'callqueue_agent_has_registered_devices', must be one of '%s'",
                $this->container['callqueue_agent_has_registered_devices'],
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getCallqueueAgentEntryTypeAllowableValues();
        if (!is_null($this->container['callqueue_agent_entry_type']) && !in_array($this->container['callqueue_agent_entry_type'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'callqueue_agent_entry_type', must be one of '%s'",
                $this->container['callqueue_agent_entry_type'],
                implode("', '", $allowedValues)
            );
        }

        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {
        return count($this->listInvalidProperties()) === 0;
    }


    /**
     * Gets synchronous
     *
     * @return \SpectrumVoip\\\\NetSapiens\Model\Synchronous|null
     */
    public function getSynchronous()
    {
        return $this->container['synchronous'];
    }

    /**
     * Sets synchronous
     *
     * @param \SpectrumVoip\\\\NetSapiens\Model\Synchronous|null $synchronous synchronous
     *
     * @return self
     */
    public function setSynchronous($synchronous)
    {
        if (is_null($synchronous)) {
            throw new \InvalidArgumentException('non-nullable synchronous cannot be null');
        }
        $this->container['synchronous'] = $synchronous;

        return $this;
    }

    /**
     * Gets callqueue_agent_id
     *
     * @return string
     */
    public function getCallqueueAgentId()
    {
        return $this->container['callqueue_agent_id'];
    }

    /**
     * Sets callqueue_agent_id
     *
     * @param string $callqueue_agent_id This is the main identifier for a \"agent\" in a queue. There are two format supported here, either a user based option which will look like user@domain or a device based method like sip:device@domain.
     *
     * @return self
     */
    public function setCallqueueAgentId($callqueue_agent_id)
    {
        if (is_null($callqueue_agent_id)) {
            throw new \InvalidArgumentException('non-nullable callqueue_agent_id cannot be null');
        }
        $this->container['callqueue_agent_id'] = $callqueue_agent_id;

        return $this;
    }

    /**
     * Gets callqueue
     *
     * @return string|null
     */
    public function getCallqueue()
    {
        return $this->container['callqueue'];
    }

    /**
     * Sets callqueue
     *
     * @param string|null $callqueue This is the callqueue id for which the agent is in. The agent may be in multiple callqueus, but this value is a single entry.
     *
     * @return self
     */
    public function setCallqueue($callqueue)
    {
        if (is_null($callqueue)) {
            throw new \InvalidArgumentException('non-nullable callqueue cannot be null');
        }
        $this->container['callqueue'] = $callqueue;

        return $this;
    }

    /**
     * Gets domain
     *
     * @return string|null
     */
    public function getDomain()
    {
        return $this->container['domain'];
    }

    /**
     * Sets domain
     *
     * @param string|null $domain This is the main organization name. This is used to link resource to its group/tenant/organization/enterprise. ~ and * can be used alone in special cases to mean My Domain (~) and All Domains (\\*).
     *
     * @return self
     */
    public function setDomain($domain)
    {
        if (is_null($domain)) {
            throw new \InvalidArgumentException('non-nullable domain cannot be null');
        }
        if ((mb_strlen($domain) > 64)) {
            throw new \InvalidArgumentException('invalid length for $domain when calling CreateAgentRequest., must be smaller than or equal to 64.');
        }
        if ((!preg_match("/^[A-Za-z0-9._-]+|\\*/", ObjectSerializer::toString($domain)))) {
            throw new \InvalidArgumentException("invalid value for \$domain when calling CreateAgentRequest., must conform to the pattern /^[A-Za-z0-9._-]+|\\*/.");
        }

        $this->container['domain'] = $domain;

        return $this;
    }

    /**
     * Gets callqueue_agent_availability_type
     *
     * @return string|null
     */
    public function getCallqueueAgentAvailabilityType()
    {
        return $this->container['callqueue_agent_availability_type'];
    }

    /**
     * Sets callqueue_agent_availability_type
     *
     * @param string|null $callqueue_agent_availability_type This is the main toggle for the agents status in the queue.  \"automatic\" is logged in, which manual is logged out with the option for one call. From a angent perspective and the actions of logging in and out the recomention would be to use the specific \"agent actions\" api instead of the basic agent update request.
     *
     * @return self
     */
    public function setCallqueueAgentAvailabilityType($callqueue_agent_availability_type)
    {
        if (is_null($callqueue_agent_availability_type)) {
            throw new \InvalidArgumentException('non-nullable callqueue_agent_availability_type cannot be null');
        }
        $allowedValues = $this->getCallqueueAgentAvailabilityTypeAllowableValues();
        if (!in_array($callqueue_agent_availability_type, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'callqueue_agent_availability_type', must be one of '%s'",
                    $callqueue_agent_availability_type,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['callqueue_agent_availability_type'] = $callqueue_agent_availability_type;

        return $this;
    }

    /**
     * Gets callqueue_agent_wrap_up_allowance_seconds
     *
     * @return int|null
     */
    public function getCallqueueAgentWrapUpAllowanceSeconds()
    {
        return $this->container['callqueue_agent_wrap_up_allowance_seconds'];
    }

    /**
     * Sets callqueue_agent_wrap_up_allowance_seconds
     *
     * @param int|null $callqueue_agent_wrap_up_allowance_seconds This is the number of seconds that the system will hold the agent offline before logging them back in automatically. This time allows the agent to comolete needed notes and conclusions to previous calls and prepare for next call.
     *
     * @return self
     */
    public function setCallqueueAgentWrapUpAllowanceSeconds($callqueue_agent_wrap_up_allowance_seconds)
    {
        if (is_null($callqueue_agent_wrap_up_allowance_seconds)) {
            throw new \InvalidArgumentException('non-nullable callqueue_agent_wrap_up_allowance_seconds cannot be null');
        }
        $this->container['callqueue_agent_wrap_up_allowance_seconds'] = $callqueue_agent_wrap_up_allowance_seconds;

        return $this;
    }

    /**
     * Gets auto_answer_enabled
     *
     * @return \SpectrumVoip\\\\NetSapiens\Model\YesNoStringNoDefault|null
     */
    public function getAutoAnswerEnabled()
    {
        return $this->container['auto_answer_enabled'];
    }

    /**
     * Sets auto_answer_enabled
     *
     * @param \SpectrumVoip\\\\NetSapiens\Model\YesNoStringNoDefault|null $auto_answer_enabled This settings will control if the the parent feature is enabled.
     *
     * @return self
     */
    public function setAutoAnswerEnabled($auto_answer_enabled)
    {
        if (is_null($auto_answer_enabled)) {
            throw new \InvalidArgumentException('non-nullable auto_answer_enabled cannot be null');
        }
        $this->container['auto_answer_enabled'] = $auto_answer_enabled;

        return $this;
    }

    /**
     * Gets callqueue_agent_dispatch_order_ordinal
     *
     * @return int|null
     */
    public function getCallqueueAgentDispatchOrderOrdinal()
    {
        return $this->container['callqueue_agent_dispatch_order_ordinal'];
    }

    /**
     * Sets callqueue_agent_dispatch_order_ordinal
     *
     * @param int|null $callqueue_agent_dispatch_order_ordinal For use in callqueues that have a linear order, this value would be to the order of the agent in that list, the lower the number the higher agent in the order.
     *
     * @return self
     */
    public function setCallqueueAgentDispatchOrderOrdinal($callqueue_agent_dispatch_order_ordinal)
    {
        if (is_null($callqueue_agent_dispatch_order_ordinal)) {
            throw new \InvalidArgumentException('non-nullable callqueue_agent_dispatch_order_ordinal cannot be null');
        }
        $this->container['callqueue_agent_dispatch_order_ordinal'] = $callqueue_agent_dispatch_order_ordinal;

        return $this;
    }

    /**
     * Gets callqueue_agent_dispatch_queue_priority_ordinal
     *
     * @return int|null
     */
    public function getCallqueueAgentDispatchQueuePriorityOrdinal()
    {
        return $this->container['callqueue_agent_dispatch_queue_priority_ordinal'];
    }

    /**
     * Sets callqueue_agent_dispatch_queue_priority_ordinal
     *
     * @param int|null $callqueue_agent_dispatch_queue_priority_ordinal This setting is a priority value for this agent's entry with respect to the other callqueues they are in. Lower number is higher priority. This means that when the agent comes back available after a call the priority would be used to determine which queue its attempted first.
     *
     * @return self
     */
    public function setCallqueueAgentDispatchQueuePriorityOrdinal($callqueue_agent_dispatch_queue_priority_ordinal)
    {
        if (is_null($callqueue_agent_dispatch_queue_priority_ordinal)) {
            throw new \InvalidArgumentException('non-nullable callqueue_agent_dispatch_queue_priority_ordinal cannot be null');
        }
        $this->container['callqueue_agent_dispatch_queue_priority_ordinal'] = $callqueue_agent_dispatch_queue_priority_ordinal;

        return $this;
    }

    /**
     * Gets limits_max_active_calls_total
     *
     * @return int|null
     */
    public function getLimitsMaxActiveCallsTotal()
    {
        return $this->container['limits_max_active_calls_total'];
    }

    /**
     * Sets limits_max_active_calls_total
     *
     * @param int|null $limits_max_active_calls_total This is the maximum number of calls an agent will be given at at time. Default and ideal is 1, but if needed it can be higher
     *
     * @return self
     */
    public function setLimitsMaxActiveCallsTotal($limits_max_active_calls_total)
    {
        if (is_null($limits_max_active_calls_total)) {
            throw new \InvalidArgumentException('non-nullable limits_max_active_calls_total cannot be null');
        }
        $this->container['limits_max_active_calls_total'] = $limits_max_active_calls_total;

        return $this;
    }

    /**
     * Gets callqueue_agent_answer_confirmation_enabled
     *
     * @return \SpectrumVoip\\\\NetSapiens\Model\YesNoStringNoDefault|null
     */
    public function getCallqueueAgentAnswerConfirmationEnabled()
    {
        return $this->container['callqueue_agent_answer_confirmation_enabled'];
    }

    /**
     * Sets callqueue_agent_answer_confirmation_enabled
     *
     * @param \SpectrumVoip\\\\NetSapiens\Model\YesNoStringNoDefault|null $callqueue_agent_answer_confirmation_enabled This settings will control if the the parent feature is enabled.
     *
     * @return self
     */
    public function setCallqueueAgentAnswerConfirmationEnabled($callqueue_agent_answer_confirmation_enabled)
    {
        if (is_null($callqueue_agent_answer_confirmation_enabled)) {
            throw new \InvalidArgumentException('non-nullable callqueue_agent_answer_confirmation_enabled cannot be null');
        }
        $this->container['callqueue_agent_answer_confirmation_enabled'] = $callqueue_agent_answer_confirmation_enabled;

        return $this;
    }

    /**
     * Gets callqueue_agent_has_registered_devices
     *
     * @return string|null
     */
    public function getCallqueueAgentHasRegisteredDevices()
    {
        return $this->container['callqueue_agent_has_registered_devices'];
    }

    /**
     * Sets callqueue_agent_has_registered_devices
     *
     * @param string|null $callqueue_agent_has_registered_devices This read only status will show the agents registration infor and if the system believes the device is registered.
     *
     * @return self
     */
    public function setCallqueueAgentHasRegisteredDevices($callqueue_agent_has_registered_devices)
    {
        if (is_null($callqueue_agent_has_registered_devices)) {
            throw new \InvalidArgumentException('non-nullable callqueue_agent_has_registered_devices cannot be null');
        }
        $allowedValues = $this->getCallqueueAgentHasRegisteredDevicesAllowableValues();
        if (!in_array($callqueue_agent_has_registered_devices, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'callqueue_agent_has_registered_devices', must be one of '%s'",
                    $callqueue_agent_has_registered_devices,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['callqueue_agent_has_registered_devices'] = $callqueue_agent_has_registered_devices;

        return $this;
    }

    /**
     * Gets callqueue_agent_availability_for_dispatch
     *
     * @return string|null
     */
    public function getCallqueueAgentAvailabilityForDispatch()
    {
        return $this->container['callqueue_agent_availability_for_dispatch'];
    }

    /**
     * Sets callqueue_agent_availability_for_dispatch
     *
     * @param string|null $callqueue_agent_availability_for_dispatch This is the status for the agent generated by the system using all available informaion.
     *
     * @return self
     */
    public function setCallqueueAgentAvailabilityForDispatch($callqueue_agent_availability_for_dispatch)
    {
        if (is_null($callqueue_agent_availability_for_dispatch)) {
            throw new \InvalidArgumentException('non-nullable callqueue_agent_availability_for_dispatch cannot be null');
        }
        $this->container['callqueue_agent_availability_for_dispatch'] = $callqueue_agent_availability_for_dispatch;

        return $this;
    }

    /**
     * Gets active_calls_total_current
     *
     * @return int|null
     */
    public function getActiveCallsTotalCurrent()
    {
        return $this->container['active_calls_total_current'];
    }

    /**
     * Sets active_calls_total_current
     *
     * @param int|null $active_calls_total_current This is the total number of calls on the agent's account across all their queues
     *
     * @return self
     */
    public function setActiveCallsTotalCurrent($active_calls_total_current)
    {
        if (is_null($active_calls_total_current)) {
            throw new \InvalidArgumentException('non-nullable active_calls_total_current cannot be null');
        }
        $this->container['active_calls_total_current'] = $active_calls_total_current;

        return $this;
    }

    /**
     * Gets last_modified_datetime
     *
     * @return \DateTime|null
     */
    public function getLastModifiedDatetime()
    {
        return $this->container['last_modified_datetime'];
    }

    /**
     * Sets last_modified_datetime
     *
     * @param \DateTime|null $last_modified_datetime This timestamp is the datetime of the last change to the agent's configuration and status
     *
     * @return self
     */
    public function setLastModifiedDatetime($last_modified_datetime)
    {
        if (is_null($last_modified_datetime)) {
            throw new \InvalidArgumentException('non-nullable last_modified_datetime cannot be null');
        }
        $this->container['last_modified_datetime'] = $last_modified_datetime;

        return $this;
    }

    /**
     * Gets callqueue_agent_max_concurrent_sms_conversations
     *
     * @return int|null
     */
    public function getCallqueueAgentMaxConcurrentSmsConversations()
    {
        return $this->container['callqueue_agent_max_concurrent_sms_conversations'];
    }

    /**
     * Sets callqueue_agent_max_concurrent_sms_conversations
     *
     * @param int|null $callqueue_agent_max_concurrent_sms_conversations This is the maximum number of SMS queue sessions the agent will be requested to handle before queing up future requests.
     *
     * @return self
     */
    public function setCallqueueAgentMaxConcurrentSmsConversations($callqueue_agent_max_concurrent_sms_conversations)
    {
        if (is_null($callqueue_agent_max_concurrent_sms_conversations)) {
            throw new \InvalidArgumentException('non-nullable callqueue_agent_max_concurrent_sms_conversations cannot be null');
        }
        $this->container['callqueue_agent_max_concurrent_sms_conversations'] = $callqueue_agent_max_concurrent_sms_conversations;

        return $this;
    }

    /**
     * Gets last_callqueue_dispatch_datetime
     *
     * @return \DateTime|null
     */
    public function getLastCallqueueDispatchDatetime()
    {
        return $this->container['last_callqueue_dispatch_datetime'];
    }

    /**
     * Sets last_callqueue_dispatch_datetime
     *
     * @param \DateTime|null $last_callqueue_dispatch_datetime This timestamp is the datetime of the last dispatch to the agent.
     *
     * @return self
     */
    public function setLastCallqueueDispatchDatetime($last_callqueue_dispatch_datetime)
    {
        if (is_null($last_callqueue_dispatch_datetime)) {
            array_push($this->openAPINullablesSetToNull, 'last_callqueue_dispatch_datetime');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('last_callqueue_dispatch_datetime', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['last_callqueue_dispatch_datetime'] = $last_callqueue_dispatch_datetime;

        return $this;
    }

    /**
     * Gets callqueue_agent_entry_type
     *
     * @return string|null
     */
    public function getCallqueueAgentEntryType()
    {
        return $this->container['callqueue_agent_entry_type'];
    }

    /**
     * Sets callqueue_agent_entry_type
     *
     * @param string|null $callqueue_agent_entry_type This is a read only field that will tell you the type of agent config that is setup, this might include device or user based agents or \"offnet\"
     *
     * @return self
     */
    public function setCallqueueAgentEntryType($callqueue_agent_entry_type)
    {
        if (is_null($callqueue_agent_entry_type)) {
            throw new \InvalidArgumentException('non-nullable callqueue_agent_entry_type cannot be null');
        }
        $allowedValues = $this->getCallqueueAgentEntryTypeAllowableValues();
        if (!in_array($callqueue_agent_entry_type, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'callqueue_agent_entry_type', must be one of '%s'",
                    $callqueue_agent_entry_type,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['callqueue_agent_entry_type'] = $callqueue_agent_entry_type;

        return $this;
    }

    /**
     * Gets login_username
     *
     * @return string|null
     */
    public function getLoginUsername()
    {
        return $this->container['login_username'];
    }

    /**
     * Sets login_username
     *
     * @param string|null $login_username This value read only from the user that is linked to this agent. Its the user's login if needed.
     *
     * @return self
     */
    public function setLoginUsername($login_username)
    {
        if (is_null($login_username)) {
            throw new \InvalidArgumentException('non-nullable login_username cannot be null');
        }
        $this->container['login_username'] = $login_username;

        return $this;
    }

    /**
     * Gets name_full_name
     *
     * @return string|null
     */
    public function getNameFullName()
    {
        return $this->container['name_full_name'];
    }

    /**
     * Sets name_full_name
     *
     * @param string|null $name_full_name This value read only from the user that is linked to this agent. Its the user's full name.
     *
     * @return self
     */
    public function setNameFullName($name_full_name)
    {
        if (is_null($name_full_name)) {
            throw new \InvalidArgumentException('non-nullable name_full_name cannot be null');
        }
        $this->container['name_full_name'] = $name_full_name;

        return $this;
    }

    /**
     * Gets agent_name_first_name
     *
     * @return string|null
     */
    public function getAgentNameFirstName()
    {
        return $this->container['agent_name_first_name'];
    }

    /**
     * Sets agent_name_first_name
     *
     * @param string|null $agent_name_first_name This value read only from the user that is linked to this agent. Its the user's first name.
     *
     * @return self
     */
    public function setAgentNameFirstName($agent_name_first_name)
    {
        if (is_null($agent_name_first_name)) {
            throw new \InvalidArgumentException('non-nullable agent_name_first_name cannot be null');
        }
        $this->container['agent_name_first_name'] = $agent_name_first_name;

        return $this;
    }

    /**
     * Gets agent_name_last_name
     *
     * @return string|null
     */
    public function getAgentNameLastName()
    {
        return $this->container['agent_name_last_name'];
    }

    /**
     * Sets agent_name_last_name
     *
     * @param string|null $agent_name_last_name This value read only from the user that is linked to this agent. Its the user's last name.
     *
     * @return self
     */
    public function setAgentNameLastName($agent_name_last_name)
    {
        if (is_null($agent_name_last_name)) {
            throw new \InvalidArgumentException('non-nullable agent_name_last_name cannot be null');
        }
        $this->container['agent_name_last_name'] = $agent_name_last_name;

        return $this;
    }

    /**
     * Gets agent_department
     *
     * @return string|null
     */
    public function getAgentDepartment()
    {
        return $this->container['agent_department'];
    }

    /**
     * Sets agent_department
     *
     * @param string|null $agent_department This value read only from the user that is linked to this agent. Its the user's depeartment.
     *
     * @return self
     */
    public function setAgentDepartment($agent_department)
    {
        if (is_null($agent_department)) {
            throw new \InvalidArgumentException('non-nullable agent_department cannot be null');
        }
        $this->container['agent_department'] = $agent_department;

        return $this;
    }

    /**
     * Gets agent_site
     *
     * @return string|null
     */
    public function getAgentSite()
    {
        return $this->container['agent_site'];
    }

    /**
     * Sets agent_site
     *
     * @param string|null $agent_site This value read only from the user that is linked to this agent. Its the user's site
     *
     * @return self
     */
    public function setAgentSite($agent_site)
    {
        if (is_null($agent_site)) {
            throw new \InvalidArgumentException('non-nullable agent_site cannot be null');
        }
        $this->container['agent_site'] = $agent_site;

        return $this;
    }

    /**
     * Gets agent_user_scope
     *
     * @return string|null
     */
    public function getAgentUserScope()
    {
        return $this->container['agent_user_scope'];
    }

    /**
     * Sets agent_user_scope
     *
     * @param string|null $agent_user_scope This value read only from the user that is linked to this agent. Its the user's scope.
     *
     * @return self
     */
    public function setAgentUserScope($agent_user_scope)
    {
        if (is_null($agent_user_scope)) {
            throw new \InvalidArgumentException('non-nullable agent_user_scope cannot be null');
        }
        $this->container['agent_user_scope'] = $agent_user_scope;

        return $this;
    }

    /**
     * Gets agent_status_message
     *
     * @return string|null
     */
    public function getAgentStatusMessage()
    {
        return $this->container['agent_status_message'];
    }

    /**
     * Sets agent_status_message
     *
     * @param string|null $agent_status_message This value read only from the user that is linked to this agent. Its the user's status message.
     *
     * @return self
     */
    public function setAgentStatusMessage($agent_status_message)
    {
        if (is_null($agent_status_message)) {
            array_push($this->openAPINullablesSetToNull, 'agent_status_message');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('agent_status_message', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['agent_status_message'] = $agent_status_message;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer $offset Offset
     *
     * @return boolean
     */
    public function offsetExists($offset): bool
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer $offset Offset
     *
     * @return mixed|null
     */
    #[\ReturnTypeWillChange]
    public function offsetGet($offset)
    {
        return $this->container[$offset] ?? null;
    }

    /**
     * Sets value based on offset.
     *
     * @param int|null $offset Offset
     * @param mixed    $value  Value to be set
     *
     * @return void
     */
    public function offsetSet($offset, $value): void
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer $offset Offset
     *
     * @return void
     */
    public function offsetUnset($offset): void
    {
        unset($this->container[$offset]);
    }

    /**
     * Serializes the object to a value that can be serialized natively by json_encode().
     * @link https://www.php.net/manual/en/jsonserializable.jsonserialize.php
     *
     * @return mixed Returns data which can be serialized by json_encode(), which is a value
     * of any type other than a resource.
     */
    #[\ReturnTypeWillChange]
    public function jsonSerialize()
    {
       return ObjectSerializer::sanitizeForSerialization($this);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString()
    {
        return json_encode(
            ObjectSerializer::sanitizeForSerialization($this),
            JSON_PRETTY_PRINT
        );
    }

    /**
     * Gets a header-safe presentation of the object
     *
     * @return string
     */
    public function toHeaderValue()
    {
        return json_encode(ObjectSerializer::sanitizeForSerialization($this));
    }
}


